Category: algorithm
Tags: algorithm
Slug: graph-algorithm-bfs-dfs
Date: 20190909
Summary: 本文讨论了图算法中的广度优先搜索算法和深度优先搜索算法，并给出了相应的python代码实现。

[TOC]



## 前言

广度优先搜索，英文名：breadth-first-search，可简写为bfs。深度优先搜索，英文名：depth-first-search，可简写为dfs。

广度优先搜索和深度优先搜索应用范围很广，既可用于图数据结构，也可用于树数据结构。其首先是一种遍历图或者树的搜索方法，其次就是利用这种遍历的过程来解决一些问题，比如求解两个节点之间的最短路径问题。

广度优先搜索在搜索过程中一般是利用一个队列来存储待处理的节点，然后在图的搜索上，是每往外扩展一级就将这些子节点加入到待处理的任务中去。

深度优先搜索是利用一种递归的写法，函数一直深入查找子节点，直到找不到子节点为止；然后再返回之前未做完的节点任务继续处理。



## 视频讲解

下面是我制作的B站视频讲解：

<div>
<iframe class="iframe-media" src="//player.bilibili.com/player.html?aid=797058713&bvid=BV1by4y1y7wp&cid=233407668&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
</div>


## 一般实现

### 广度优先搜索

```python
    def bfs_search(self, start):
        """
        Breadth-first search.
        """
        def bfs():
            """
            Breadth-first search sub-function.
            """
            while queue:
                node = queue.popleft()

                if node not in visited:
                    for other in self.neighbors(node):
                        bfs_tree.insert_child(node, other)
                        queue.append(other)

                    visited.append(node)

        queue = deque()  # Visiting queue
        visited = []
        bfs_tree = Tree(start)
        queue.append(start)

        bfs()
        return bfs_tree
```

这里我们利用在 [树算法建模初步]({filename}./树算法建模初步.md) 一文中讨论的Tree类树数据结构来进行遍历过程生成树的结果存储。

### 深度优先搜索

```python

    def dfs_search(self, start):
        """
        Depth-first search.
        """
        def dfs(node):
            """
            Depth-first search sub-function.
            """
            for other in self.neighbors(node):
                dfs_tree.insert_child(node, other)
                dfs(other)

        dfs_tree = Tree(start)
        dfs(start)

        return dfs_tree
```

## 最小路径问题求解

当我们求出了那个生成树，实际上最小路径问题，从start到end，选择end那个level层级最小的节点，然后最小路径就出来了。这其中可以对上面的生成树过程做一些小的优化：

```python
   def bfs_shortest_path_search(self, start, end):
        def bfs():
            """
            Breadth-first search sub-function.
            """
            while queue:
                node = queue.popleft()

                if node not in visited:
                    for other in self.neighbors(node):
                        if other == end:
                            bfs_tree.insert_child(node, other)
                            break
                        else:
                            bfs_tree.insert_child(node, other)
                            queue.append(other)

                    visited.append(node)

        queue = deque()  # Visiting queue
        visited = []
        bfs_tree = Tree(start)
        queue.append(start)

        bfs()
        return bfs_tree

    def dfs_shortest_path_search(self, start, end):
        def dfs(node):
            """
            Depth-first search sub-function.
            """
            for other in self.neighbors(node):
                if other == end:
                    dfs_tree.insert_child(node, other)
                    break
                else:
                    dfs_tree.insert_child(node, other)
                    dfs(other)

        dfs_tree = Tree(start)
        dfs(start)

        return dfs_tree
```

具体就是当找到目标节点之后，至少我们能够确认目标节点的兄弟节点是没必要再找下去了，因为再找下去只可能是更长的路径。

