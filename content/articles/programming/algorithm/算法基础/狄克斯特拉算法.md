Category: algorithm
Slug: dijkstra-algorithm
Tags: algorithm
Date: 20190910

[TOC]

## 前言

狄克斯特拉算法是用于加权有向图寻找最短路径的算法。所谓加权有向图就是在有向图的基础上每个边增加了权重属性。更确切来说狄克斯特拉算法只适用于加权有向无环图，而且权重不能为负权重。

就加权有向无环图的实现来说当然可以继承自有向无环图，然后再新增一个 weight_data 这个字典值来存储各个边的权重值。定义默认权重值为1。

如下图所示，我们如何找到从1到4的最短路径呢：

![img]({static}/images/2020/狄克斯特拉算法样例.png)

具体狄克斯特拉算法搜索过程用自然语言描述如下：

1. 初始化一个costs字典，除了起点为0外，其他都设为infinite。
2. 从这个costs字典里面找寻cost最小的顶点
3. 计算该顶点下面的子节点的总cost——从起点算起的。如果发现找到了新的路径该路径cost和我们之前记录的costs里面的值相比更小，那么说明我们找到了一个更好的路径。我们这里应该采用一种树结构来记录这个最小路径树，因为这里找到了更好的路径，所以之前的子节点关联的路径应该移除，再插入新的路径。
4. 该顶点处理完了记录下来，后面不再处理了。继续从costs里面找cost最小的顶点，继续按照最小cost开销向下扩展。最终我们会得到一个最小路径树。

## 基本实现

```python

    def _init_costs(self, start):
        costs = {}
        for node in self.nodes():
            if node == start:
                costs[node] = 0
            else:
                costs[node] = float("inf")
        return costs

    @staticmethod
    def _find_lowest_cost_node(costs, processed):
        """
        start - node the total cost
        always return the lowest cost node.
        """
        lowest_cost = float("inf")
        lowest_cost_node = None

        for node, cost in costs.items():
            if cost < lowest_cost and node not in processed:
                lowest_cost = cost
                lowest_cost_node = node
        return lowest_cost_node

    def dijkstra_search(self, start):
        """
        return the shortest path tree
        """
        processed = []
        costs = self._init_costs(start)
        node = self._find_lowest_cost_node(costs, processed)
        spt = Tree(node)

        while node is not None:
            cost = costs[node]
            for sub_node in self.neighbors(node):
                new_cost = cost + self.edge_weight((node, sub_node))
                if costs[sub_node] > new_cost:
                    costs[sub_node] = new_cost

                    if spt.has_node(sub_node):
                        spt.remove_child(sub_node)
                    spt.insert_child(node, sub_node)

            processed.append(node)
            node = self._find_lowest_cost_node(costs, processed)

        return spt
```

狄克斯特拉用更通俗的话语来表述就是逐渐往外扩展所有可能的路径，到某个节点最小cost的路径最终将会被记录下来。

继续到实际的最短路径问题，我们需要加上如下两句来降低程序搜索开销：

```python
            ......
            processed.append(node)
            node = self._find_lowest_cost_node(costs, processed)

            if node == end:
                break

        return spt
```

最终我们利用之前Tree已经写好的 `shortest_path_to` 方法很容易就得到了最小开销路径：

```python
    def dijkstra_shortest_path(self, start, end):
        spt = self.dijkstra_shortest_path_search(start, end)
        min_path = spt.shortest_path_to(end)
        return [i.name for i in min_path]
```

上面的样例图片情况转成测试代码如下：

```
    graph = WeightedDAG()
    graph.add_edge(('1', '3'), 9)
    graph.add_edge(('1', '6'), 14)
    graph.add_edge(('1', '2'), 7)
    graph.add_edge(('2', '3'), 10)
    graph.add_edge(('6', '5'), 9)
    graph.add_edge(('5', '4'), 6)
    graph.add_edge(('3', '4'), 11)
    graph.add_edge(('2', '4'), 15)

    assert graph.dijkstra_shortest_path('1', '4') == ['1', '3', '4']
```







## 参考资料

1. [Dijkstra’s shortest path algorithm](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)