Category: algorithm
Tags: algorithm
Slug: directied-acyclic-graph
Date: 2019

[TOC]

图论，听起来挺高大上的，嗯，那就是数学家画圈圈和画线线还很有乐趣的地方。

如果线没有方向，那么叫做无向图，如果线有方向，那么叫做有向图。

在有向图中，任意一个节点的流向流着流着都流不回自身，那么我们就说这个图为 **有向无环图** ，英文缩写是 DAG，（directied acyclic graph）。

这东西有什么用？

一开始我最先接触 DAG 这个术语，是在找工作流软件的时候，一种工作流的通用表示方法就是用 DAG 来表示。为什么？假设你是工作流中的某个节点的员工，你按照某个workflow走下去，最后闭环了，然后你无限循环在某个流程中了，那可真蠢了。

然后比如说 git 的版本控制，其内部也是用的 有向无环图表示，如果你版本修改修改，又回到某个老版本了，那版本控制也失效了。

聪明的朋友肯定想到了我们的宇宙时间是不可逆的，也就是说如果用模型来表示宇宙所有的信息数据变动流结构的话，那么一定是有向无环图。



## python实现

在 [algorithms项目的这里](https://github.com/nryoung/algorithms/blob/master/algorithms/data_structures/digraph.py) 有有向图的实现代码，实际存储就是一个字典值，然后再加上了一些辅助方法，其中 key 就是节点的值，value是一个列表，存放着本节点到其他节点的流向地。整个实现过程还是很好理解的，在jieba分词中：

```python
    def get_DAG(self, sentence):
        self.check_initialized()
        DAG = {}
        N = len(sentence)
        for k in xrange(N):
            tmplist = []
            i = k
            frag = sentence[k]
            while i < N and frag in self.FREQ:
                if self.FREQ[frag]:
                    tmplist.append(i)
                i += 1
                frag = sentence[k:i + 1]
            if not tmplist:
                tmplist.append(k)
            DAG[k] = tmplist
        return DAG
```

其大体也是类似这样的实现。

也就是在实际操作中，并没有对无环条件进行判断，这多少有点出乎我的意料之外。图论里面关于这个已经有算法了，我们也没什么好想的，就是图论的拓扑排序方法来判断一个有向图是否是无环的。

wiki上有伪代码，我们可以下看一下：

```
L ← Empty list that will contain the sorted elements
S ← Set of all nodes with no incoming edge
while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
if graph has edges then
    return error (graph has at least one cycle)
else 
    return L (a topologically sorted order)
```

这个算法叫做 Kahn 算法，具体思路就是请读者假想目标研究有向图里面有一个闭环，那么这个闭环里面的所有节点都有有进入箭头的，也就是其不可能在set S，其在算法中只可能在 m 中被选中，而且闭环中的节点一定不会出现在n中，这样上面的算法再怎么运算，if语句对于闭环中的m来说都不会成立。

然后假设某几个节点都有入口，那么顺藤摸瓜，逐个删除是可以把这些节点都放到S里面去的。

我心里还有一个担心，也就是上面的算法的终止问题，主要是闭环那边。初步的判断是闭环内的节点m不会进入S，其他节点慢慢会被放入L。OK，让我们开始写代码，然后再实际看一下吧。

下面的代码除了参考了上面提及的 algorithm 项目之外， 还参看了 [这个网页](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/) ，然后进行了深度优化。

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from copy import deepcopy
from collections import defaultdict

import logging
logger = logging.getLogger(__name__)

class CyclicError(Exception):
    pass


class DAG():
    def __init__(self):
        self._dag = defaultdict(list)
        self._vertex_count = 0
        self._edge_count = 0

    @property
    def data(self):
        return self._dag

    @property
    def vertex_count(self):
        """
        Returns the number of vertices in the graph.
        Worst Case Complexity: O(1)
        """
        return self._vertex_count

    @property
    def edge_count(self):
        """
        Returns the number of edges in the graph.
        Worst Case Complexity: O(1)
        """
        return self._edge_count

    def add_edge(self, src, dest):
        """
        Adds an undirected edge 'src'-'dest' to the graph.
        Worst Case Complexity O(1)
        """

        def _add_edge(self, src, dest):
            if src in self._dag:
                if dest not in self._dag[src]:
                    self._dag[src].append(dest)
                    self._edge_count += 1
                else:
                    logger.warning('src->dest already exists')
            else:
                self._dag[src] = [dest]
                self._vertex_count += 1
                self._edge_count += 1

            if dest not in self._dag:
                self._dag[dest] = []
                self._vertex_count += 1


        backup = deepcopy(self)
        _add_edge(backup, src, dest)

        if not backup.sort():
            raise CyclicError
        else:
            _add_edge(self, src, dest)


    def remove_edge(self, src, dest):
        """
        remove edge src -> dest
        """
        if src in self._dag:
            if dest in self._dag[src]:
                self._dag[src].remove(dest)
                self._edge_count -= 1
            else:
                raise ValueError
        else:
            raise ValueError

        ## clear data
        if self.indegree(src) == 0 and self.outdegree(src) == 0:
            if src in self._dag:
                del self._dag[src]
                self._vertex_count -= 1

        if self.indegree(dest) == 0 and self.outdegree(dest) == 0:
            if dest in self._dag:
                del self._dag[dest]
                self._vertex_count -= 1

    def adjacent(self, src):
        """
        Returns the vertices adjacent to vertex 'src'.
        Worst Case Complexity: O(1)
        """
        return self._dag[src]

    def outdegree(self, src):
        """
        Returns the degree of the vertex 'src'
        Worst Case Complexity: O(1)
        """
        count = 0
        if src in self._dag:
            count = len(self._dag[src])

        return count

    def indegree(self, src):
        """
        Returns the in degree of the vertex 'src'
        """
        count = 0
        for k, v in self._dag.items():
            if src in v:
                count += 1

        return count

    @property
    def vertices(self):
        """
        Returns an iterable of all the vertices in the graph.
        Worst Case Complexity: O(V)
        """
        return self._dag.keys()

    def __str__(self):
        s = []
        s.append("{0} vertices and {1} edges \n".format(self.vertex_count,
                                                        self.edge_count))
        for key in self.vertices:
            s.append("{0}: ".format(key))
            for val in self.adjacent(key):
                s.append("{0} ".format(val))
            s.append("\n")

        return "".join(s)

    def __repr__(self):
        s = []
        for key in self.vertices:
            s.append("{0}: ".format(key))
            for val in self.adjacent(key):
                s.append("{0} ".format(val))
            s.append("\n")

        return ''.join(s)

    def sort(self):
        """
        L ← Empty list that will contain the sorted elements
        S ← Set of all nodes with no incoming edge
        while S is non-empty do
            remove a node n from S
            add n to tail of L
            for each node m with an edge e from n to m do
                remove edge e from the graph
                if m has no other incoming edges then
                    insert m into S
        if graph has edges then
            return error (graph has at least one cycle)
        else
            return L (a topologically sorted order)
        """
        target = deepcopy(self)
        top_order = []

        from collections import deque
        queue = deque()
        for k in target.vertices:
            if target.indegree(k) == 0:
                queue.append(k)
                logger.debug('queue append {0}'.format(k))

        while queue:
            n = queue.pop()
            top_order.append(n)

            for m in self.adjacent(n):
                target.remove_edge(n, m)
                logger.debug('remove n->m {0} {1}'.format(n, m))
                if target.indegree(m) == 0:
                    logger.debug('append {0}'.format(m))
                    queue.append(m)

        if len(top_order) != len(self.vertices):
            return False
        else:
            return top_order
```



