Category: algorithm
Slug: graph-algorithm-first-lesson
Tags: algorithm
Date: 20190909

[TOC]

## 前言

我们在解决现实世界中的一些问题的时候，常常很自然地进行一些作图来试着对这些问题进行建模，其中有一些问题的最核心的部分可以精简为如下一种用小圆点和连接这些小圆点的直线来表示出来：

![img]({static}/images/2020/directed_acyclic_graph_example.png)

这些小圆点叫做 **顶点** ，连接这些顶点的直线或者曲线叫做 **边** 。

顶点记作Node，边记作edge。然后整个图的所有顶点数目叫做该图的阶，记作Order。

图里面的边可能有方向也可能没方向，一般用带箭头的直线来表示该边有方向。如果边没有方向，那么叫做 **无向图**，如果线有方向，那么叫做 **有向图** 。

在有向图里面，有 **入度** 和 **出度** 这两个专业术语，其中某个顶点的入度是指进入该顶点的边条数；而某个顶点的出度是指从该顶点出来的边条数。其中入度记作 in-degree ， 出度记作 out-degree。 

## 基本实现

### Graph类

```python
class Graph(ABC):
    """
    general graph class
    """
    DIRECTED = None

  @abstractmethod
    def nodes(self):
        raise NotImplementedError("Not Implement nodes methods")

    @abstractmethod
    def neighbors(self, node):
        raise NotImplementedError("Not Implement neighbors methods")

    @abstractmethod
    def edges(self):
        raise NotImplementedError("Not Implement edges methods")

    @abstractmethod
    def has_node(self, node):
        raise NotImplementedError("Not Implement has_node methods")

    @abstractmethod
    def has_edge(self, edge):
        raise NotImplementedError("Not Implement has_edge methods")

    @abstractmethod
    def add_node(self, node):
        raise NotImplementedError("Not Implement add_node methods")

    @abstractmethod
    def add_edge(self, edge):
        raise NotImplementedError("Not Implement add_edge methods")
```

图Graph是抽象基类，具体后面某个图要么是有向图要么是无向图，这个后面再讨论。

这里定义了一些基本的方法，要求后面的图具体实现都应该有这些方法：

- DIRECTED 属性： True说明该图是有向图，False则说明该图是无向图。
- nodes方法：遍历本图的各个顶点
- neighbors方法：返回与某个顶点相邻的顶点
- edges方法：遍历本图的各个边，这个也是一个抽象方法，这样具体边的相似判断可以往后面放。
- has_node方法：本图是否有该顶点，这里顶点是某个唯一标识的字符串
- has_edge方法：本图是否有该边，同样具体edge的存储形式和判断都往后面放。
- add_node方法：增加一个节点
- add_edge方法： 增加一个边

### UndirectedGraph类

无向图的数据采用这样的形式：

```
    {
        'a': {'b','z'}
    }
```

该字典的keys表示该图的所有顶点，然后后面的值就是具体与该顶点相邻的那些顶点，于是有：

```python
class UndirectedGraph(Graph):
    """
    graph_data structure as:
    {
        'a': {'b','z'}
    }
    """
    DIRECTED = False

    def __init__(self, graph_data=None):
        """
        Initialize a graph.
        """

        if graph_data is None:
            self.graph_data = {}
        else:
            self.graph_data = graph_data

    def nodes(self):
        """
        Return node list.
        """
        return self.graph_data.keys()

    def neighbors(self, node) -> list:
        """
        Return all nodes that are directly accessible from given node.
        """
        return list(self.graph_data[node])
```

接下来遍历边一个技巧是使用字典 `{a,b}` 这样的形式来表示无向图的边，这样边就和连接的两个顶点的顺序无关了。

**NOTICE** 顶点a到顶点a的边字典形式是 `{a}` ，其长度为1，这需要额外处理一下。

```python
    def _read_edge(self, edge):
        data = copy(edge)

        if len(data) == 1:
            u = v = data.pop()
        elif len(data) == 2:
            u, v = data
        else:
            raise Exception("wrong edge format")

        return u, v
    
    def _generate_edges(self):
        """
        represent edge as {a,b}
        """
        edges = []
        for node in self.nodes():
            for neighbour in self.neighbors(node):
                if {neighbour, node} not in edges:
                    edges.append({node, neighbour})
        return edges

    def edges(self):
        """
        Return all edges in the graph.
        """
        return self._generate_edges()
    
    def has_node(self, node) -> bool:
        """
        Return whether the requested node exists.
        """
        return node in self.graph_data
    
    def has_edge(self, edge) -> bool:
        """
        Return whether an edge exists.
        """
        u, v = self._read_edge(edge)

        return {u, v} in self.edges()
```

新增一个顶点和新增一个边后面再讨论，下面来看有向图那边的情况。

### DirectedGraph类

有向图的数据存储结构为：

```
     {
         'a': ['b','z']
     }
```

其中该字典的keys是该图的各个顶点，然后后面的值就是具体该顶点指向的那些相邻的顶点。于是有：

```python

class DirectedGraph(Graph):
    """
    graph_data structure as:
     {
         'a': ['b','z']
     }
     """
    DIRECTED = True

    def __init__(self, graph_data=None):
        """
        Initialize a graph.
        """

        if graph_data is None:
            self.graph_data = {}
        else:
            self.graph_data = graph_data

    def nodes(self):
        """
        Return nodes
        """
        return self.graph_data.keys()

    def neighbors(self, node):
        """
        Return all nodes that are incident to the given node.
        """
        return self.graph_data[node]
```

接下来是遍历边的实现，其才用了 `(a,b)` 这样的形式来表示有向图的边，这样边就和连接的两个顶点的顺序有关了。

```python

    def _generate_edges(self):
        """
        represent edge as (a,b)
        """
        edges = []
        for node in self.nodes():
            for neighbor in self.neighbors(node):
                if (node, neighbor) not in edges:
                    edges.append((node, neighbor))
        return edges

    def edges(self):
        """
        Return all edges in the graph.
        """
        return self._generate_edges()
    
    def has_node(self, node) -> bool:
        """
        Return whether the requested node exists.
        """
        return node in self.graph_data
    
    def has_edge(self, edge) -> bool:
        """
        Return whether an edge exists.
        """
        u, v = edge
        return (u, v) in self.edges()
```



## 其他丰富完善

### 增加节点

无向图是：

```
    def add_node(self, node):
        """
        Add given node to the graph.
        """
        if self.has_node(node):
            raise AdditionError("Node %s already in graph" % node)

        self.graph_data[node] = set()
```

有向图是：

```
    def add_node(self, node):
        """
        Add given node to the graph.
        """
        if self.has_node(node):
            raise AdditionError("Node {0} already in digraph".format(node))

        self.graph_data[node] = []
```

这个没啥好说的。

### 增加边

无向图：

```python
    def add_edge(self, edge):
        """
        Add an edge to the graph connecting two nodes.
        """
        u, v = self._read_edge(edge)

        if self.has_edge(edge):
            raise AdditionError("Edge ({0}, {1}) already in graph".format(u, v))

        for n in [u, v]:
            if n not in self.graph_data:
                self.add_node(n)

        self.graph_data[u].add(v)
        if u != v:
            self.graph_data[v].add(u)
```

有向图：

```python
    def add_edge(self, edge):
        """
        Add an directed edge to the graph connecting two nodes.
        """
        u, v = edge
        if self.has_edge(edge):
            raise AdditionError("Edge (%s, %s) already in digraph" % (u, v))

        for n in [u, v]:
            if n not in self.graph_data:
                self.add_node(n)

        self.graph_data[u].append(v)
```

这里我们利用之前已经写好的 `has_edge` 方法会让程序逻辑更清晰一些。

无向图因为没有方向，所有从u到v和从v到u需要添加两次。



### 有向图的入度和出度

```python
    def out_degree(self, node):
        """
        return the target node's out degree
        """
        count = 0
        if node in self.graph_data:
            count = len(self.graph_data[node])

        return count

    def in_degree(self, node):
        """
        return the target node's in degree
        """
        count = 0
        for k, v in self.graph_data.items():
            if node in v:
                count += 1

        return count
```

