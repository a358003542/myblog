Category: algorithm
Tags: algorithm
Slug: tree-algorithm-first-lesson
Date: 2019

[TOC]



## 前言

树应该也算作图的一种，不过具体到计算机算法数据结构这块树和图是分开讨论了。树和一般图的区别在于其有一个特殊的节点，该节点没有父节点被称作为根节点，也就是树的根节点入度为0，其他节点入度为1。节点的出度并没有限制。然后树是无环的。

![img]({static}/images/2020/tree_data_structure_example.png)

树被称为Tree，这些节点仍然称作 Node。取消树的入度称呼，用某节点的度degree来描述该节点的出度。新增parent和children概念，其中parent=None的节点为根节点，children为空的列表的表示该节点没有子节点，即度为0的终端节点。

从根节点开始定义根节点的层次level为1，下面根节点的子节点层次level为2，后面以此类推。



## 基本实现

```python
class Tree(object):
    """
    the brother nodes can not have the same name.
    """

    def __init__(self, name, parent=None):
        self.name = name
        self.parent = parent
        self.children = []

    def __iter__(self):
        """
        iter all nodes, dfs style.
        """
        if self.name is not None:
            yield self

            for child in self.children:
                for i in child:
                    yield i

    def __str__(self):
        if self.parent is None:
            return '<Tree: {0}>'.format(self.name)
        else:
            return '<TreeNode: {0}>'.format(self.name)

    def __repr__(self):
        if self.parent is None:
            return '<Tree: {0}>'.format(self.name)
        else:
            return '<TreeNode: {0}>'.format(self.name)

    def has_node(self, node):
        """
        check whether this tree has this node.
        only check the node's name.
        """
        if isinstance(node, Tree):
            name = node.name
        elif isinstance(node, str):
            name = node
        else:
            raise TypeError("node wrong type")

        for target in self:
            if target.name == name:
                return True

        return False

    def has_child(self, node):
        """
        check whether this node has this child node.
        only check the node's name
        """
        if isinstance(node, Tree):
            name = node.name
        elif isinstance(node, str):
            name = node
        else:
            raise TypeError("node wrong type")

        for child in self.children:
            if child.name == name:
                return True

        return False

    def insert_child(self, parent_name, child_name):
        """
        insert a child
        """
        target = self[parent_name]

        if target.has_child(child_name):
            raise Exception("child name exists")
        else:
            target.children.append(Tree(child_name, parent=target))

    def __getitem__(self, name):
        """
        get target node only return first found one
        """
        for target in self:
            if target.name == name:
                return target
        raise KeyError

    def get_nodes(self, name):
        """
        get all target
        """
        for target in self:
            if target.name == name:
                yield target

    def to_json(self):
        return {self.name: [i.to_json() for i in self.children]}

    @property
    def level(self):
        level = 1
        target = self

        while target.parent is not None:
            level += 1
            target = target.parent

        return level
```



