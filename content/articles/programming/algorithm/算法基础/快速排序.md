Category: algorithm
Tags: algorithm
Slug: quick-sort
Date: 2019



## 前言

快速排序的基本思路是利用递归的思想，将大问题转变成小问题。

利用递归解决问题大概需要确定这两点：

1. 递归的终点
2. 递归问题的切分

快排递归的终点是如果序列长度小于2，则其顺序自然是有效的。

快排递归问题的切分是取一个点，这个点其实是随意的，将比这个元素小的放一边，将比这个元素大的放一边。于是形成了这样的有效顺序： `less_part pivot greater_part` 。然后对less_part 和 greater_part同样继续这样的操作，再将结果列表组合起来即可。

```python
def quick_sort(seq):
    """
    10000 random number seq ：
    select_sort use time 3.0919713973999023
    quick sort use time 0.024930477142333984

    """
    if len(seq) < 2:
        return seq
    else:
        pivot = seq[0]

        less_part = [i for i in seq[1:] if i <= pivot]

        greater_part = [i for i in seq[1:] if i > pivot]

        return quick_sort(less_part) + [pivot] + quick_sort(greater_part)
```

快排的算法复杂度是 O(nlogn)，在排序算法里面算是第一梯队了，效率很高。当n不大的时候快速排序或者选择排序差别不大，当n很大的时候快速排序就比选择排序快很多了，具体奥秘就在其算法复杂度上。

快速排序计算复杂度的估算里面有两部分：

1. 小部分和大部分合计约n的比较判断操作

2. 递归层级展开，递归层级深度展开要看你选的那个pivot分割点情况如何，最不好的情况这个pivot总是最小的，那么递归树深度带来的复杂度将达到O(n)；最好的情况就是pivot分割点均分列表，于是递归树深度带来的复杂度是 $log_2n$ 。

实际情况既不是最好也不是最坏，考虑到对数复杂度是可以不考虑log函数的底数因子的，所以可以认为快速排序计算复杂度就是 $O(n\log(n))$ 。