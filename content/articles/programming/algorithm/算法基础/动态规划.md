Category: algorithm
Tags: algorithm
Date: 2019
Slug: dynamic-programming

[TOC]

动态规划算法采用分治思想，将某个大问题分解为一些小问题。而贪婪算法对于那些小问题求解局部最优即可，动态规划和朴素解法一样，也是要试着尝试各种组合情况的，所不同的是采用了记忆策略，来将某些类似的子问题一并解决。所以动态规划算法第一，其必须要求子问题有某种类似性；第二，对子问题的解答应用了一种记忆策略。

算法图解的动态规划算法是采用一种网格思路，这对于最长公共子序列问题似乎很适合：



## 最长公共子序列问题



```python


"""

动态规划法解最长公共子序列问题，经典案例，还是很实用的。

子序列不一定要求递增的，更多的是比较相似度

"""

import pandas as pd


def longest_common_subsequence(seq_one, seq_two):
    df = pd.DataFrame(index=[item for item in seq_one], columns=[item for item in seq_two])

    df = df.fillna(0)

    for i, c1 in enumerate(seq_one):
        for j, c2 in enumerate(seq_two):
            if c1 == c2:
                if (i - 1 < 0) or (j - 1 < 0):
                    df.iloc[i][j] = 1
                else:
                    df.iloc[i][j] = df.iloc[i - 1][j - 1] + 1
            else:
                if i < 1 and j < 1:
                    df.iloc[i][j] = 0
                elif i < 1:
                    df.iloc[i][j] = max(0, df.iloc[i][j - 1])
                elif j < 1:
                    df.iloc[i][j] = max(df.iloc[i - 1][j], 0)
                else:
                    df.iloc[i][j] = max(df.iloc[i - 1][j], df.iloc[i][j - 1])
    print(df)


longest_common_subsequence('fort', 'fosh')
longest_common_subsequence('fish', 'fosh')
```





