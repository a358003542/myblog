Category: algorithm
Tags: algorithm

[TOC]

动态规划算法感觉这个名字取的很唬人，一开始也是类似于贪婪算法，采用分治思想，将某个大问题分解为一些小问题。而贪婪算法对于那些小问题求解局部最优即可，动态规划和朴素解法一样，也是要试着尝试各种组合情况的，所不同的是采用了记忆策略，来将某些类似的子问题一并解决。所以动态规划算法并不如它的名字那样感人，第一，其必须要求子问题有某种类似性；第二，具体也不过是一种记忆策略罢了。

算法图解的动态规划算法是采用一种网格思路，这对于最长公共子序列问题似乎很适合，而MIT的python编程导论在解决背包问题的时候提出了一种决策树的思路。思考过之后觉得如果某个问题具有很强烈的空间排列组合特性，那么就采用类似解决最长公共子序列问题的网格思路；如果某个问题具有很强烈的时间决策展开性，应该选用决策树。





## 背包问题

如下构建决策树之后：

```python

class BinaryDecisionTree(object):
    """
    二叉决策树

    决策函数 data
    decisions = [('a',True), ('b',False)] 决定了决策树中节点在决策树中的位置

    """

    def __init__(self, data=None, decisions=None, parent=None):
        self.left = None
        self.right = None

        self.data = data

        if decisions is None:
            decisions = []

        self.decisions = decisions

        self.parent = parent

    def __repr__(self):
        return '<BinaryDecisionTree {0} {1}>'.format(self.decisions, self.data)

    def append(self, child_data, new_decision):
        """
        本节点附加
        :param child_data:
        :param new_decision:
        :return:
        """
        bool_key, bool_value = new_decision
        if bool_value:
            decisions = self.decisions + [new_decision]
            self.left = BinaryDecisionTree(child_data, decisions=decisions, parent=self)
            return self.left
        else:
            decisions = self.decisions + [new_decision]
            self.right = BinaryDecisionTree(child_data, decisions=decisions, parent=self)
            return self.right

    def insert(self, child_data, decisions, auto_create=False):
        """
        插在某个节点上
        :param bool_key:
        :param child_data:
        :return:
        """

        if len(decisions) == 1:
            target = self.find()
            new_decision = decisions
        else:
            target = self.find(decisions[:-1], auto_create=auto_create)
            new_decision = decisions[-1]

        new_node = target.append(child_data, new_decision=new_decision)
        return new_node

    def find(self, decisions=None, auto_create=False):
        if decisions is None:
            assert self.parent is None
            return self

        res = None

        for target in self.introspection():
            if target.decisions == decisions:
                res = target
                return res

        if res is None:
            if auto_create:
                for i in range(1, len(decisions) + 1):
                    decisions_small = decisions[:i]
                    if not self.find(decisions_small):
                        self.insert(child_data=None, decisions=decisions_small)
            else:
                return None

    def set_data(self, data):
        self.data = data

    def introspection(self):
        stack = []
        node = self
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                yield node
                node = node.right
        return stack

    def children_count(self):
        """Return the number of children

        @returns number of children: 0, 1, 2
        """
        cnt = 0
        if self.left:
            cnt += 1
        if self.right:
            cnt += 1
        return cnt
```

发现不是很好动态规划了，因为现在这里主要的开销应该是如何节省构建决策树，然后只好又实现了一种类似贪婪算法的东西，尽量节省node的生成。

总的说来动态规划算法算不上很神奇的东西，就到此为止吧。


```python

item_a = Item('a', 6, 3)
item_b = Item('b', 7, 3)
item_c = Item('c', 8, 2)
item_d = Item('d', 9, 5)
items = [item_a, item_b, item_c, item_d]

import heapq


class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]


def dynamic_programming2(items, max_node=None):
    """
    利用决策树来进行动态规划

    引入优先级队列来减少决策树构建成本
    :param knapsack:
    :param items:
    :return:
    """

    tree = BinaryDecisionTree(data={
        'pre': [],
        'post': items,
        'value': 0,
        'freespace': 5
    })

    q = PriorityQueue()
    q.push(tree, 0)

    node_num = 1
    while q._queue:
        if max_node and node_num > max_node:
            break

        target = q.pop()
        import copy
        data = copy.deepcopy(target.data)
        data_pre = data['pre']
        data_post = data['post']
        data_value = data['value']
        data_freespace = data['freespace']

        try:
            item = data_post.pop(0)

            data = {
                'pre': data_pre,
                'post': data_post,
                'value': data_value,
                'freespace': data_freespace
            }
            node = target.append(data, new_decision=(item.name, False))
            node_num += 1
            q.push(node, data_value)

            data_pre = data_pre + [item]
            data_value += item.value
            data_freespace -= item.weight

            data = {
                'pre': data_pre,
                'post': data_post,
                'value': data_value,
                'freespace': data_freespace
            }
            if data_freespace < 0:
                pass
            else:
                node = target.append(data, new_decision=(item.name, True))
                node_num += 1
                q.push(node, data_value)
        except IndexError:
            pass

    max_value = 0
    target_node = None
    for node in tree.introspection():
        value = node.data['value']
        if value > max_value:
            target_node = node
            max_value = value

    return target_node

```



​       



## 最长公共子序列问题

```python

"""

和最长公共子序列的区别是必须是递增的。

"""

import pandas as pd


def longest_increasing_subsequence(seq_one, seq_two):
    df = pd.DataFrame(index=[item for item in seq_one], columns=[item for item in seq_two])

    for i, c1 in enumerate(seq_one):
        for j, c2 in enumerate(seq_two):
            if c1 == c2:
                if (i - 1 < 0) or (j - 1 < 0):
                    df.iloc[i][j] = 1
                else:
                    df.iloc[i][j] = df.iloc[i - 1][j - 1] + 1
            else:
                df.iloc[i][j] = 0
    print(df)

longest_increasing_subsequence('fish', 'hish')
longest_increasing_subsequence('hish', 'vista')

```





```python


"""

动态规划法解最长公共子序列问题，经典案例，还是很实用的。

子序列不一定要求递增的，更多的是比较相似度

"""

import pandas as pd


def longest_common_subsequence(seq_one, seq_two):
    df = pd.DataFrame(index=[item for item in seq_one], columns=[item for item in seq_two])

    df = df.fillna(0)

    for i, c1 in enumerate(seq_one):
        for j, c2 in enumerate(seq_two):
            if c1 == c2:
                if (i - 1 < 0) or (j - 1 < 0):
                    df.iloc[i][j] = 1
                else:
                    df.iloc[i][j] = df.iloc[i - 1][j - 1] + 1
            else:
                if i < 1 and j < 1:
                    df.iloc[i][j] = 0
                elif i < 1:
                    df.iloc[i][j] = max(0, df.iloc[i][j - 1])
                elif j < 1:
                    df.iloc[i][j] = max(df.iloc[i - 1][j], 0)
                else:
                    df.iloc[i][j] = max(df.iloc[i - 1][j], df.iloc[i][j - 1])
    print(df)


longest_common_subsequence('fort', 'fosh')
longest_common_subsequence('fish', 'fosh')
```





