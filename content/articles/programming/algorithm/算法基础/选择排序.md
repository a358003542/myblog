Category: algorithm
Tags: algorithm
Slug: select-sort
Date: 2019



## 前言

选择排序基本思路是非常直观的，就是遍历序列，找到最小的那个，将其放在第一位，然后剩下的继续找最小的。作为排序算法的第二梯队，第一梯队是指快速排序和其他变种，冒泡排序显得有点故弄玄虚了。对于不是特别的大型序列来说，实际上选择排序仍然是不错的算法。

下面先给出python语言版本的最易懂的写法，和后面那种写法从算法运行效率方面差别不大。

```python

def select_sort2(seq):
    """
    :param seq:
    :return:
    """

    def find_smallest_index(seq):
        smallest = seq[0]
        smallest_index = 0
        for i in range(1, len(seq)):
            target = seq[i]
            if target < smallest:
                smallest = target
                smallest_index = i
        return smallest_index

    res = []
    seq_copy = seq.copy()

    for i in range(0, len(seq)):
        smallest_index = find_smallest_index(seq_copy)
        res.append(seq_copy.pop(smallest_index))

    return res
```

上面这个实现之所以易懂是因为其就是选择排序思路的直接书写，找到最小的那个元素，然后取出，再找再取出，如此找完。

## C语言版本

```c
void select_sort(int array[], int num) {
	int temp;
	for (int i = 0; i < num; i++) {
		for (int j = i + 1; j < num; j++) {
			if (array[i] > array[j]) {
				temp = array[i];
				array[i] = array[j];
				array[j] = temp;
			}
		}
	}
}
```

## python语言版本

```python
def select_sort(seq):
    seq2 = seq.copy()
    for i in range(0, len(seq2)):
        minimum = i
        for j in range(i + 1, len(seq2)):
            if seq2[j] < seq2[minimum]:
                minimum = j
        seq2[i], seq2[minimum] = seq2[minimum], seq2[i]

    return seq2
```

基本过程都大同小异，就是利用两个遍历动作来形成A,B这样的比较对，然后再决定采取什么行为。python语言版本一些额外的动作是因为希望返回的序列是另外的序列，原序列必变，而C语言版本原数组是就地修改的。

## 算法复杂度

选择排序计算复杂度粗略估计是长度的 $O(n^2)$ ，核心占用时间动作就是那个循环套循环。

这里就顺便说下快速排序，同样的python语言版本，10000个随机数列表排序用时如下：

```
    10000 的随机数列表排序：
    select_sort use time 3.0919713973999023
    quick sort use time 0.024930477142333984
```

我们看到快速排序相比选择排序确实快了太多了。