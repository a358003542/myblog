Title: python语言学习之-官方模块第二谈
Slug: python-modules-two
Date: 2017-05-08
Modified: 2019-06-05


[TOC]





shelve模块
----------

shelve模块是基于pickle模块的，也就是只有pickle模块支持的对象它才支持。
之前提及pickle模块只能针对一个对象，如果你有多个对象要处理，可以考虑使用shelve模块，而shelve模块就好像是自动将这些对象用字典的形式包装起来了。除此之外shelve模块的使用更加简便了。

### 存入多个对象

我们根据类的操作第三版中定义的类（[12.5](#sec:类的操作第三版){reference-type="ref"
reference="sec:类的操作第三版"}）建立了一个Hero.py文件，就是将那些类的定义复制进去。然后我们新建了几个实例来存入test.db文件中。

    import shelve
    from Hero import Garen
    
    if __name__ == '__main__':
        garen1=Garen()
        garen2=Garen('red')
        garen3=Garen('yellow')
        db=shelve.open('test.db')
        for (key,item) in [('garen1',garen1),('garen2',garen2),('garen3',garen3)]:
            db[key]=item
        db.close()

我们看到整个过程的代码变得非常的简洁了，然后一个个对象是以字典的形式存入进去的。

### 读取这些对象

读取这些对象的代码也很简洁，就是用shelve模块的open函数打开数据库文件，open函数会自动返回一个字典对象，这个字典对象里面的数据就对应着之前存入的键值和对象。

同时通过这个例子我发现，如果自己定义的类，将他们提取出来放入另外一个文件，那么shelve模块读取文件时候是不需要再引入之前的定义。这一点值得我们注意，因为shelve模块内部也采用的是pickle的机制，所以可以猜测之前pickle的那个例子类的定义写在写入文件代码的里面，所以不能载入数据库；而如果将这些类的定义放入一个文件，然后这些类以模块或说模块载入的形式引入，那么读取这些对象就可以以一种更优雅的形式实现。如下所示：

    import shelve
    
    if __name__ == '__main__':
        db=shelve.open('test.db')
        for key in sorted(db):
            print(db[key])
        db.close()

我们看到就作为简单的程序或者原型程序的数据库，shelve模块已经很好用而且够用了。

更多内容请参见[官方文档](https://docs.python.org/3/library/shelve.html)。





pickle模块
----------

pickle模块可以将某复杂的对象永久存入文件中，以后再导入这个文件，这样自动将这个复杂的对象导入进来了。

### 将对象存入文件

    import pickle
    
    class Test:
        def __init__(self):
            self.a=0
            self.b=0
            self.c=1
            self.d=1
    
        def __str__(self):
            return str(self.__dict__)
    
    if __name__ == '__main__':
        test001=Test()
        print(test001)
        testfile=open('data.pkl','wb')
        pickle.dump(test001,testfile)
        testfile.close()

### 从文件中取出对象

值得一提的是从文件中取出对象，原来的类的定义还是必须存在，也就是声明一次在内存中的，否则会出错。

    import pickle
    
    class Test:
        def __init__(self):
            self.a=0
            self.b=0
            self.c=1
            self.d=1
    
        def __str__(self):
            return str(self.__dict__)
    
    if __name__ == '__main__':
        testfile=open('data.pkl','rb')
        test001=pickle.load(testfile)
        print(test001)
        testfile.close()

pickle模块的基本使用就是用dump函数将某个对象存入某个文件中，然后这个文件以后可以用load函数来加载，然后之前的那个对象会自动返回出来。

更多内容请参见[官方文档](https://docs.python.org/3/library/pickle.html)。



pathlib模块
-----------

自python3.4以后起，python3就内置了pathlib模块了。之前的python版本，需要通过pip安装pathlib，后面的使用也差不了太多了。下面的讨论主要参考了python3.4的pathlib模块的官方文档，以其为准。

这个模块主要让我们对系统的路径更加灵活的操作，python取代bash进行系统运维的时候，有大量的对文件名，路径等的操作，pathlib将大大简化我们在这一块的工作量。首先来看一个例子：

    from pathlib import Path
    import os
    
    p1 = Path(os.path.expanduser('~'))
    p2 = Path('.')
    
    print([x for x in p1.glob("*.pdf") if x.is_file()])
    print([x for x in p2.iterdir() if x.is_dir()])

这里Path是可以接受相对路径语法的，所以\".\"和\"..\"都是可用的。然后Path对象有方法glob和iterdir方法，其中glob就是类似linux的glob命令；然后iterdir将遍历当前目录。遍历之后返回了一个可迭代对象（读者可以看一下，是一个生成器对象），展开之后仍然是一个Path对象。然后Path对象有
`is_file` 方法和 `is_dir` 方法来判断该Path对象是不是文件夹或者文件路径。

Path对象有很多便捷的方法，很是好用，比如： **iterdir** ， **exists** ，
**is\_file** ， **is\_dir** ， **parents** ， **cwd**
等等。更多信息请参看官方文档。


marshal模块可以将python的一些变量以二进制的形式读写入文件中，比如jieba分词的词典缓存就是这么做的。

官方文档推荐如果确实有类似的简单存储需求，推荐是使用pickle或者shelve模块，不管怎么说，这个模块简单的使用我们了解下吧。

其支持的对象类型有：

>The following types are supported: booleans, integers, floating point numbers, complex numbers, strings, bytes, bytearrays, tuples, lists, sets, frozensets, dictionaries

简单的使用如下：

```python
with open(cache_file, 'rb') as cf:
    self.FREQ, self.total = marshal.load(cf)

with open(cache_file, 'wb') as temp_cache_file:
    marshal.dump((self.FREQ, self.total), temp_cache_file)
```

load方法加载目标文件对象，返回值是你之前送入的对象。

dump方法是把你想要送进去的对象，送入到某个文件中去。





logging模块
-----------

在软件开发中，两个东西最易被初学者忽视，但实际上却是最有用的工具:
一个是单元测试；一个是日志输出管理。python的官方内置模块logging可以帮助你更好地管理自己的日志汇报系统。一个好的日志汇报系统不仅能够帮助程序员调试debug，用户向专业人员汇报发生错误时候的信息，还可以帮助人们理解程序具体是如何运行的和运行到了那里，在干些什么，这些都是非常有用的。

### 什么时候使用logging

有的时候一些简单的函数调试就可以使用print函数来进行一些输出信息，这在编程早期还是有用的。而后续不管是调试还是编程都推荐使用单元测试的方法。而在大型软件项目中，print函数则是更应该少出现，只有那些程序员希望用户看到的信息才能使用print函数（当然某些经过io重定向的print函数不在这里的讨论范围之内）。

程序员有时想要看看某个大型软件内部具体是如何运作的，丑陋的做法是print，然后注释掉。这样也不是不可以，只是最好程序员做的一切工作都能保存起来拿到台面上，毕竟这都是劳动。logging模块的第一个用途就出来了:
我们可以使用 `logging.info()`
这个函数，来输出某些信息，这些信息只有在你调低了logging等级之后（默认的是
**WARNING** ），才会显示出来。低于 **WARNING** 等级的还有一个函数
`logging.debug()`
。info函数的信息通常是程序员用来确认程序是按照预期运行的，debug函数的信息通常是出现某个bug了，程序员希望有助于他debug的输出信息。

`logging.warn()`
函数用来发出警告信息，并且程序员应该修改程序来避免这个信息出现；
`logging.warning`
函数用来发出警告信息，这种情况程序员表示在我的预料之中，是用户不应该这样做，程序不需要修改，但信息应该被记录。

然后特别重大的错误或异常捕捉，这个使用python的 `try... except...`
语句，或者raise抛出异常，这自不必多说。只是有某些情况，程序员不愿抛出这个异常，而是希望压抑这个错误，则可以使用logging模块的
`error()` 函数或者 `exception()` 函数或者 `critical()` 函数。

具体这些函数的严重等级是:

最简单的一个使用例子如下所示:

    import logging
    
    logging.basicConfig(level=logging.DEBUG)
    
    logging.debug('debug')
    logging.info('info')
    logging.warning('warning')

这里的basicConfig函数对整个日志系统进行一些配置。比如这里设置日志报告等级
`level=logging.DEBUG` ，这样我们将会看到 **DEBUG** 以及 **DEBUG**
以上等级的日志信息；然后如果设置为 `logging.INFO` ，则就只看到 **INFO**
和 **INFO** 以上等级的信息了。

### 将日志信息输出到文件

更专业的做法是将日志输出到文件中去，即使是自己调试，对于大型软件项目来说，日志信息是很多的，将其保存到文件，然后用编辑器或者shell工具或者其他工具查看会更便捷一些。要将这些日志信息都输出到某个文件中很简单，在
**basicConfig** 设置 `filename` 参数即可:

    import logging
    
    logging.basicConfig(filename='test.log', level=logging.DEBUG)
    
    logging.debug('debug')
    logging.info('info')
    logging.warning('warning')

默认的 **filemode** 是 \"a\"
，也就是日志信息一直累积在那里。你可以多运行几次这个小py脚本，来看看具体的效果。
**filemode** 也可以设置为 \"w\" ，则只保存最后那次运行的日志信息。

### logging模块中级教程

logging模块的中级使用需要了解如下几个词汇：loggers, handlers, filters,
and formatters。

#### loggers

**记录器**
之前我们运行logging.info，就是调用的默认的记录器，然后一般我们会针对每个python的模块文件创建一个记录器。

    logger = logging.getLogger(__name__)

这个 `__name__`
只是一种简便的命名方法，如果你勤快或者某种情况下有需要的话完全可以自己手工给记录器取个名字。

然后这个 `getLogger`
函数如果你后面指定的名字之前已经定义了（这通常是指在其他第三方模块下定义了），那么你通过这个
`getLogger`
然后指定目标名字就会得到对应的该记录器。这通常对于DIY某个第三方模块的日志记录器有用。

记录器可以挂载或者卸载某个处理器对象或过滤器对象：

-   logger.addHandler()

-   logger.removeHandler()

-   logger.addFilter()

-   logger.removeFilter()

记录器通过 `setLevel()`
方法来设置最小记录级别，这个和后面的Handler级别是协作关系。

记录器的propagate参数这里值得详细说下，记录器的名字自己定义也好，还是用
`__name__`
这样python自带的模块结构语法也好，其有个上层和下层的关系，比如说
`main.test` 这个记录器是属于 `main` 这个记录器的。而这里讨论的
`propagate` 参数，默认是True，也就是发送给 `main.test`
记录器的信息也会传递给其上层 `main`
记录器上去。如果设置为False则不会往上传递了。

#### handlers

**处理器**负责分发日志信息到目标地去。这里主要介绍这几个Handler类：

StreamHandler

:   将信息以流的形式输出，这通常指输出到终端

FileHandler

:   将信息写入到某个文件中去

RotatingFileHandler

:   将信息写入某个文件，如果文件大小超过某个值，则另外新建一个文件继续写。

TimeRotatingFileHandler

:   将信息写入某个文件，每隔一段时间，比如说一天，就会自动再新建一个文件再往里面写。

处理器对象也有 `setLevel` 方法，这个前面也提及了，和记录器的 `setLevel`
是协作关系，更详细的描述是，信息先记录器处理并分发给对应的处理器对象，然后再处理器处理再分发到目的地。

处理器可以挂载 **格式器** 对象和 **过滤器** 对象。

-   handler.setFormatter()

-   handler.addFilter()

-   handler.removeFilter()

#### filters

**过滤器**

#### formatters

**格式器**，具体信息的格式定义。

这里的format涉及到的一些参数设置如下所示:

    -   %(levelname)s 类似'DEBUG'这样的logging level
    -   %(message)s 具体输出的信息
    -   %(asctime)s 具体时间，默认是'2003-07-08 16:49:45,896'，你可以通过 **datefmt** 选项来进一步设置格式，格式设置和strftime命令类似。
    -   %(filename)s 文件名，更简洁的表达是模块名。
    -   %(module)s 模块名
    -   %(funcName)s 函数名
    -   %(lineno)d 具体logging代码在第几行
    
    -   %(name)s logger的名字，默认是'root'。
    -   %(process)d 进程号
    -   %(processName)s 进程名
    -   %(thread)d 线程号
    -   %(threadName)s 线程名

### 字典统一配置

django的setting.py就会有这样的配置，具体含义还是很明显的，就是定义处理器，格式器，记录器等。

    LOGGING = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'simple': {
                'format': "%(asctime)s %(name)s [%(levelname)s] %(thread)d %(module)s %(funcName)s %(lineno)s: %(message)s"
            }
        },
        'handlers': {
            'log_file': {
                'class': 'sdsom.common.log.DedupeRotatingAndTimedRotatingFileHandler',
                'filename': config.get('web', 'log_path'),
                'when': 'midnight',
                'maxBytes': int(config.get('web', 'log_max_bytes')),
                'interval': 1,
                'backupDay': int(config.get('web', 'log_backup_days')),
                'dedupetime': int(config.get('web', 'log_dedupe_time')),
                'formatter': 'simple'
            },
        },
        'loggers': {
            'django.request': {
                'handlers': ['log_file'],
                'level': config.get('web', 'log_level'),
                'propagate': True,
            },
        }
    }




json模块
--------

### 什么是json

json全称是JavaScript Object Notation，也就是JavaScript对象表示法。json是一种基于文本的，人类易读的数据存储交互格式。json文件保存使用后缀 `.json` 。虽然json是从javascript语言衍生出来，不过其作为数据存储和交互是独立于语言的。json和xml作为数据存储和交互方案相比有更易读和读写速度更快的特点。

### json存储格式语法

json存储格式的语法很简单，首先是最基本的数字开始，其支持两种数字类型，整数型和浮点型，其对应于python的int和float；字符串在双引号里面，其对应于python的字符串概念；布尔值true和false，其对应于python的True和False，然后还有一个null对应于python的None；json数据用`[]`表示，里面的元素用逗号分隔，其对应的正是python的列表概念；然后json的object对象用`{}` 包围，其内是key:value这样的形式，其正对应于python的字典概念。

python语言已经内置了json模块，所以要读写json文件只需要简单 `import json`即可。

首先让我们小试牛刀，把 `[1,2,3,4,5]` 这组数存( **dump**)进test.json文件里面去。

```python
import json
lst = [1,2,3,4,5]

with open('test.json',mode='w',encoding='utf-8') as f:
    json.dump(lst,f)
```

json不支持元组(tuple)和字节(bytes)类型，bytes类型一般不会去惊扰它，如果有tuple元组你需要存储，那么将其转换成列表即可。

简单的读取是使用的json的 `load` 函数，如下所示：

```python
with open('test.json', mode='r', encoding='utf-8') as f:
    lst2 = json.load(f)
```

这样lst2就被赋值  `[1,2,3,4,5]` 了，方便后面的运算。

### 存储字典值

上面的例子稍作修改即可以存储字典值了：

```python
import json
dict01 = {'a':1,'b':2,'c':[1,2,3]}

with open('test.json', mode='w', encoding='utf-8') as f:
    json.dump(dict01,f)

with open('test.json', mode='r', encoding='utf-8') as f:
    dict02 = json.load(f)

print(dict02)
```



### 存储到文件的一些美化

上面的dump函数那句读者可以考虑加入 `indent` 选项：

```python
json.dump(dict01,f,indent=4)
```

这样我们的test.json文件里面的数据会进行一些缩进，会更好看一些了。

此外 `sort_keys`选项有时会很有用，默认是False，如果设置为True，则输出的文件的key是排序了的 。

此外 `ensure_ascii` 选项默认是True，中文字符保存会变为 `\uabcd` 之类的东西，如果设置为False，则能显示正常的中文字符。

### dumps和loads函数

dumps和loads函数是非文件接口版，简单了解下即可。



itertools模块 
-------------

### repeat函数

其定义函数如下：

    def repeat(object, times=None):
        # repeat(10, 3) --> 10 10 10
        if times is None:
            while True:
                yield object
        else:
            for i in range(times):
                yield object

也就是返回一个可迭代对象，这么封装最大的一个用处是用于填充map函数或者zip函数的某个常数值。因为你填写repeat(5)之后将一个返回一个可迭代对象，不停的返回数字5而不需要你考虑长度问题。

### starmap函数

starmap函数具体定义如下所示：

    def starmap(function, iterable):
        # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000
        for args in iterable:
            yield function(*args)

其接受一个可迭代对象，然后逐个将可迭代对象中的元素解包之后送入函数当参数（最后当然函数也执行了）。





inspect模块
-----------

更多信息请参看
[官方文档\](](https://docs.python.org/3.4/library/inspect.html) 。

### getfile函数

传入python
object，返回定义该object具体是在那个文件中的。可以如下获取该文件的系统绝对路径地址:

    os.path.abspath(inspect.getfile(func))

值得一提的是，如果该模块被安装进入系统了，那么实际该文件的地址应该是类似这样的形式:

    /usr/local/lib/python3.4/dist-packages/infome-15.10.30-py3.4.egg/infome/web/youdao.py

。

### getcallargs函数

如下所示:

    params = inspect.getcallargs(func,*args,**kargs)

相当于模拟执行了func函数，然后返回如果执行func函数时其接受的参数字典值（包括必填参数和可选参数）。





functools模块
-------------

### partial类

functools模块定义了一个partial类，其输入参数如下所示:

        functools.partial(func, *args, **keywords)

其将返回一个partial对象，其有 `__call__`
方法，也就是其可以类似函数进行调用。然后其有 **func**
属性，作为未来函数的调用； **args** 属性，作为未来函数的参数；
**keywords** 属性，作为未来函数的可选参数。
简单来说就是partial对原函数对象func进行了封装（所以其特别适合做装饰器），
`newfun=partial(func,args,keywords)`
，使得调用这个newfun对象就好像调用原func一样，只是加上了额外的参数，其中args非可选参数是类似列表append形式，而keywords可选参数或说关键字参数是类似字典update形式。

下面是一个简单的演示例子:

    import functools
    
    def fun1(a,b=2):
        print('called fun1 with',a,b)
    
    def show_details(name,f,is_partial=False):
        print(name)
        print(f)
        if is_partial:
            print(f.func)
            print(f.args)
            print(f.keywords)
        else:
            print(f.__name__)
    
    show_details('fun1',fun1)
    
    fun1('fun1 a')
    
    p1 = functools.partial(fun1,'p1 a',b=99)
    show_details('p1',p1,True)
    
    p1()

其输出如下:

        fun1
        <function fun1 at 0xb705880c>
        fun1
        called fun1 with fun1 a 2
        p1
        functools.partial(<function fun1 at 0xb705880c>, 'p1 a', b=99)
        <function fun1 at 0xb705880c>
        ('p1 a',)
        {'b': 99}
        called fun1 with p1 a 99

这里的逻辑是首先正常执行fun1，然后将fun用partial封装成p1，新增参数字符串'p1
a'和b=4，后面我们可以看到这个p1的参数都加进去了。然后执行这个p1我们看到了参数的变化。







datetime模块
------------

简单的日期时间操作用time模块里面的一些函数即可，datetime模块是用类的方式来处理的，适合大量处理日期时间的任务。然后值得一提的是mongodb的python接口
*pymongo* 里面（连接mongodb的python第三方模块），日期时间的输入输出都是
datetime 对象的，这很是方便。

下面简要介绍之，更多内容请参看
[官方文档](https://docs.python.org/3.4/library/datetime.html) 。

### timedelta对象

通过timedelta函数返回一个timedelta对象，也就是一个表示时间间隔的对象。函数参数情况如下所示:

    class datetime.timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])

其没有必填参数，简单控制的话第一个整数就是多少天的间隔的意思:

    datetime.timedelta(10)

两个时间间隔对象可以彼此之间相加或相减，返回的仍是一个时间间隔对象。而更方便的是一个datetime对象如果减去一个时间间隔对象，那么返回的对应减去之后的datetime对象，然后两个datetime对象如果相减返回的是一个时间间隔对象。这很是方便。

### datetime对象

通过datetime函数可以创建一个datetime对象:

    class datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])

其中year，month和day是必填参数。下面是一个简单的例子:

    >>> db_t = {
    ...  "date": datetime.datetime(1777,07,07)
    ... }
    >>> db_t
    {'date': datetime.datetime(1777, 7, 7, 0, 0)}

其通过pymongo存入mongodb之后是这样的形式:

    ISODate("1777-07-07T00:00:00.000Z")

#### now和utcnow方法

datetime对象有 `now` 和 `utcnow`
这两个*类方法*（classmethod）来返回当前日期时间的datetime对象。utcnow不可以接受参数，now方法可以接受一个tz指定时区的参数，我们可以通过
*pytz* 模块（一个处理时区推荐的第三方模块）来具体指明某个时区。

##### 查看pytz的所有时区

参看
[这个网页](http://stackoverflow.com/questions/13866926/python-pytz-list-of-timezones)
。

    >>> pytz.all_timezones
    ['Africa/Abidjan', 'Africa/Accra', 'Africa/Addis_Ababa', 'Africa/Algiers', ......

##### 具体给now方法指定一个时区

参看
[这个网页](http://stackoverflow.com/questions/2331592/datetime-datetime-utcnow-why-no-tzinfo)
。

    import pytz
    datetime.datetime.now(tz = pytz.timezone("Asia/Hong_Kong"))

##### now方法和utcnow方法区别

我们看下面这个例子:

    >>> datetime.now(tz = pytz.timezone("UTC")),datetime.utcnow()
    (datetime.datetime(2015, 7, 11, 9, 25, 20, 266863, tzinfo=<UTC>), datetime.datetime(2015, 7, 11, 9, 25, 20, 266888))

如果我们给now方法指定默认的时区是\"UTC\"，那么我们看到其返回的datetime对象和utcnow返回的datetime对象基本上没什么区别，后面的微秒（
$10^{-6}$
秒）有点区别完全可以理解。然后我们再看now方法如果不加任何参数会如何:

    >>> now
    datetime.datetime(2015, 7, 11, 16, 34, 43, 144018)
    >>> utcnow
    datetime.datetime(2015, 7, 11, 8, 34, 56, 319108)

这里now显示的时间和本地的时间是一致的，说明now默认的时区是本地的时区参数。谈到这里大家应该就明白了，如果是后台数据库有日期时间输入需求，为了保持时间戳的一致性，推荐都使用utcnow方法来生成时间戳，也就是实际上都以UTC格林威治时区为准。如果到前端需要显示给用户具体的日期时间了，如果要引用前端数据库的日期时间，才需要引入时区的考虑进行必要的转换。然后如果前端需要用python生成实时的时间，那么就用now方法再引入pytz的时区控制。

#### datetime对象的属性

    >>> from datetime import datetime
    >>> d = datetime.now()
    >>> d.year
    2015
    >>> d.month
    11
    >>> d.day
    3
    >>> d.hour
    18
    >>> d.minute
    42
    >>> d.second
    57
    >>> d.tzinfo
    >>> d
    datetime.datetime(2015, 11, 3, 18, 42, 57, 919613)

具体含义如下所示:

year

:   年

month

:   月

day

:   日

hour

:   时

minute

:   分

second

:   秒

microsecond

:   微秒

#### strftime方法

datetime对象可以如下调用 `strftime` 方法或者 `__format__`
方法来得到一个好看的你想要的日期时间字符串格式:

        >>> from datetime import datetime
        >>> d = datetime.now()
        >>> d.strftime('%T')
        '18:52:39'
        >>> d.__format__('%F')
        '2015-11-03'

这里的格式符号python官方文档有所述及，而更实际上是和linux系统下的 `date`
命令的格式符一致的，读者可以用 `date --help`
来看一下，就可以看到如下信息:

        %%      一个文字的 %
        %a      当前locale 的星期名缩写(例如： 日，代表星期日)
        %A      当前locale 的星期名全称 (如：星期日)
        %b      当前locale 的月名缩写 (如：一，代表一月)
        %B      当前locale 的月名全称 (如：一月)
        %c      当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)
        %C      世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)
        %d      按月计的日期(例如：01)
        %D      按月计的日期；等于%m/%d/%y
        %e      按月计的日期，添加空格，等于%_d
        %F      完整日期格式，等价于 %Y-%m-%d
        %g      ISO-8601 格式年份的最后两位 (参见%G)
        %G      ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用
        %h      等于%b
        %H      小时(00-23)
        %I      小时(00-12)
        %j      按年计的日期(001-366)
        %k   hour, space padded ( 0..23); same as %_H
        %l   hour, space padded ( 1..12); same as %_I
        %m   month (01..12)
        %M   minute (00..59)
        %n      换行
        %N      纳秒(000000000-999999999)
        %p      当前locale 下的"上午"或者"下午"，未知时输出为空
        %P      与%p 类似，但是输出小写字母
        %r      当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)
        %R      24 小时时间的时和分，等价于 %H:%M
        %s      自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数
        %S      秒(00-60)
        %t      输出制表符 Tab
        %T      时间，等于%H:%M:%S
        %u      星期，1 代表星期一
        %U      一年中的第几周，以周日为每星期第一天(00-53)
        %V      ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)
        %w      一星期中的第几日(0-6)，0 代表周一
        %W      一年中的第几周，以周一为每星期第一天(00-53)
        %x      当前locale 下的日期描述 (如：12/31/99)
        %X      当前locale 下的时间描述 (如：23:13:48)
        %y      年份最后两位数位 (00-99)
        %Y      年份
        %z +hhmm                数字时区(例如，-0400)
        %:z +hh:mm              数字时区(例如，-04:00)
        %::z +hh:mm:ss  数字时区(例如，-04:00:00)
        %:::z                   数字时区带有必要的精度 (例如，-04，+05:30)
        %Z                      按字母表排序的时区缩写 (例如，EDT)

其中的 `%F` 和 `%T` 在python官方文档中并无说明，可见其内部API是和这个
`date` 命令一致的。

#### 支持的时间间隔运算

前面提到了一个datetime对象减去一个timedelta对象返回一个datetime对象，然后一个datetime对象减去一个datetime对象返回一个时间间隔对象。比如此时之前一年的时间可以这样表达
`datetime.datetime.utcnow() - datetime.timedelta(365)`
。然后此时和爱因斯坦的生日时间间隔可以这样表达:

    datetime.datetime.utcnow() - datetime.datetime(1879,03,14)

然后我们可以利用这个时间间隔来进行一些操作和判断。

        >>> delta = datetime.datetime.utcnow() - datetime.datetime(1879,03,14)
        >>> delta
        datetime.timedelta(49792, 35970, 903285)
        >>> delta > datetime.timedelta(120*365)
        True
        >>> delta.days // 365
        136

### struct\_time 对象转化成为 datetime 对象

参看
[这个网页](http://stackoverflow.com/questions/1697815/how-do-you-convert-a-python-time-struct-time-object-into-a-datetime-object)

    from time import mktime

mktime函数接受time模块的 `struct_time` object，其可以来自time模块的
`gmtime` 、`localtime` 、 `strptime`
这些函数，mktime函数将返回一个时间戳，然后用datetime模块的
`fromtimestamp` 函数可以接受这个时间戳。

总的过程即:

    from time import mktime
    from datetime import datetime
        
    dt = datetime.fromtimestamp(mktime(struct))

### datetime 对象转化为 time\_struct 对象

参考了
[这个网页](http://stackoverflow.com/questions/8022161/python-converting-from-datetime-datetime-to-time-time)

        >>> t = datetime.datetime.now()
        >>> t
        datetime.datetime(2011, 11, 5, 11, 26, 15, 37496)
        
        >>> time.mktime(t.timetuple()) + t.microsecond / 1E6
        1320517575.037496