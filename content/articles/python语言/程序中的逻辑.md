Title: python语言学习之-程序中的逻辑
Date: 2016-03-05
[TOC]



## 布尔值

boolean类型，和大多数语言一样，就两个值：**True**，**False**。然后强制类型转换使用函数**bool**。

### 其他逻辑小知识

在python中，有些关于逻辑真假上的小知识，需要简单了解下。

-   数0、空对象或者其他特殊对象None值都认为是假

-   其他非零的数字或非空的对象都认为是真

-   前面两条用bool函数可以进行强制类型转换

-   比较和相等测试会递归作用在数据结构中

-   比较和相等测试会返回True或False

上面最后两条在说个什么东西，读者请看下面这一小节。

### 元组和列表的比较大小

元组和列表的相等判断还是很好理解的，而对于这样的东西:

    >>> (1,-1) < (2,-2)

确实就有点古怪了。请读者参考[这个网页](http://stackoverflow.com/questions/5292303/python-tuple-comparison))，按照官方文档的说明：

> Tuples and lists are compared lexicographically using comparison of
> corresponding elements. This means that to compare equal, each element
> must compare equal and the two sequences must be of the same type and
> have the same length.

官方文档对于大于小于的情况并没有说得很清楚，然后我们从字里行间大体领会的精神是:

1.  可迭代对象比较大小，是逐个比较的。

2.  可迭代对象比较和相等测试最后一定返回True或False。

3.  逐个比较首先比较是不是相等，如果相等则跳过这个元素的比较，直到遇到某两个不相等的元素，然后返回的就是这两个元素的比较结果。

4.  最后快比较完了（以最小的可迭代对象长度为准），然后如果是相等判断操作，则长度相等就认为两者相等了；而如果是大小判断操作，则认为长度更长的那个对象更大。

下面是一些例子:

    >>> (1,-1) < (2,-2)
    True
    >>> (1,-1) < (-1,-2)
    False
    >>> (1,-1,-3) < (1,-1)
    False
    >>> (1,-1,) < (1,-1,0)
    True

### None

有些函数没有return的值就会返回None值，None值是NoneType对象中的一个值，和列表的空值等是不同的，它和其他任何值都不一样的。比如re.search如果没有找到匹配就会返回None值。这个时候需要知道的是None值在逻辑上是逻辑假，not
None是逻辑真。

    >>> def f():
    ...  pass
    ... 
    >>> y = f()
    >>> y
    >>> type(y)
    <class 'NoneType'>

## if条件判断

python中的条件语句基本格式如下：

    if  test:
        条件判断执行区块

也就是if命令后面跟个条件判断语句，然后记住加个冒号，然后后面缩进的区块都是条件判断为真的时候要执行的语句。

    if  test:
        do something001
    else :
        do something002

这里的逻辑是条件判断，如果真，do something001；如果假，do something002。

    if  test001:
        do something001
    elif test002:
        do something002

显然你一看就明白了，elif是else和if的结合。

### 逻辑与或否

and表示逻辑与，or表示逻辑或，not表示逻辑否。

下面编写一个逻辑，判断一个字符串，这个字符串开头必须是a或者b，结尾必须是s，倒数第二个字符不能是单引号'。在这里就演示一下逻辑。。

    x='agais'
    if ((x[0] == 'a' or x[0] == 'b')
        and x[-1] =='s'
        and (not x[-2] =="'")):
        print('yes it is..')
    
    yes it is..

### 稍复杂的条件判断

现在我们了解了if，elif和else语句，然后还了解了逻辑与或非的组合判断。那么在实际编程中如何处理复杂的条件逻辑呢？

首先能够用逻辑语句"与或非"组合起来的就将其组合起来，而不要过分使用嵌套。如下面代码所示，如果一个情况分成两部分，那么就用if\...else\...语句，

    x=-2
    if x>0:
        print('x大于0')
    else:
        print('x小于0')

而如果一个情况分成三部分，那么就用if\...elif\...else语句。同一深度的这些平行语句对应的是"或"逻辑，或者说类似其他编程语言的switch语句。

    x=2
    if x>0:
        print('x大于0')
    elif x<0:
        print('x小于0')
    else:
        print('x等于0')

我们再看一看下面的代码，这个代码是*错误的*，两个if语句彼此并不构成逻辑分析关系。[^7]

    x=2
    if x>0:
        print('x大于0')
    if x<0:
        print('x小于0')
    else:
        print('x等于0')

然后我们看到下面的代码，这个例子演示的是在加深一个深度的条件判断语句它当时处于的逻辑判断情况，这个语句的条件判断逻辑是本语句的判断逻辑再和左边（也就是前面）的判断逻辑的"与"逻辑，或者说成是"交集"。比如说*print('0\<x\<2')*这个语句就是本语句的判断逻辑*x\<2*和上一层判断逻辑*x\>0*的"交集"，也就是*0\<x\<2*。

    x=-2
    if x>0:
        print('x大于0')
        if x>2:
            print('x>2')
        elif x<2:
            print('0<x<2')
        else:
            print('x=2')
    elif x<0:
        print('x小于0')
    else:
        print('x等于0')

整个过程的情况如下图所示：

![img]({static}/images/python/fu-za-tiao-jian-pan-duan.png "复杂条件判断")

为了在编程的时候对处于何种判断逻辑之下有一个清晰的认识，强烈建议读者好好思考一下。毕竟磨刀不误砍柴功。

### try语句捕捉错误

try语句是编程中用来处理可能出现的错误或者已经出现但并不打算应付的错误最通用的方式。比如一个变量你预先想的是接受一个数值，但是用户却输入了一个字符，这个时候你就可以将这段语句包围在try里面；或者有时你在编程的时候就发现了这种情况，只是懒得理会他们，那么简单的把这块出错的语句包围在try里面，然后后面跟个except语句，打印出一个信息"出错了"，即可。用法如下所示：

    while True:
        x=input('请输入一个数，将返回它除以2之后的数值\n输入"quit"退出\n')
        if x=='quit':
            break
        try :
            num=float(x)
            print(num/2)
        except:
            print('出错了')

#### 异常处理完整语句

    try:
        yourCode
    except yourError:
        do something
    except yourError2:
        do something2
    ......
    else:
        do somethingN
    finally:
        do the funallystuff

这个语句的逻辑是试着执行try区块下的语句，如果出现异常，那么看是不是异常yourError，如果是则执行do
something，如果是yourError2，则执行do something2
\...\...等等，如果没有异常，则执行else字句: do
somethingN，如果还有异常，则这个异常将会返回（更上面的控制程序）。

那么finally语句的作用是什么呢，finally语句实际上和整个语句中异常判断情况没有关系，不管有没有异常发生，最后它都将被执行。和简单地不缩进直接写在下面的语句比起来，finally语句的特点就是就算程序发生异常了，它也会先被执行，然后将异常上传给上面的控制程序。

else语句和finally语句是可选的，根据具体情况来看。

#### for里面放try语句的情况

for语句里面放上try语句还需要细讲一下。

具体try语句相关逻辑前面说过了，这里的问题是for语句的继续执行问题。首先是第一个情况，try字句里面使用return，这在函数里面是会跳出for语句的，也就是执行多次只要成功一次就会被跳出。然后错误捕捉，如果错误捕捉里面再放入一个raise语句，再抛出一个错误，这个时候for语句是会被中止的。然后抛出这个异常。然后是else字句，其逻辑是try多次没有错误，那么将会执行else字句，但是如果你try一次，然后else语句里面加入break命令，则会跳出for语句的。

这里面情况稍微有点复杂，目前我接触到的有如下两种应用:

这是一个mongodb的安全调用的函数装饰器。其在试图调用mongodb的时候，如果发生AutoReconnect异常，那么将会sleep一秒然后再去try
之前的那个调用函数。如果成功了，那么进入return，然后自然就跳出for语句了。

    def safe_mongocall(call):
        '''mongodb replica set assistant'''
        def _safe_mongocall(*args, **kwargs):
            for i in xrange(100):#
                try:
                    return call(*args, **kwargs)
                except pymongo.AutoReconnect:
                    import time
                    time.sleep(1)
                    print("try to connect mongodb again...")
        return _safe_mongocall

第二个例子较为常用，就是在重复做某件事的时候可能会发生错误，然后捕捉这个错误，然后继续执行。然后捕捉的时候计了一下数。

    def test():
        failcount = 0
    
        for i in range(src_count):
            try:
                do something
            except Exception as ex:
                failcount += 1
    
        sucess_count = src_count - failcount
        return sucess_count

其实我们还可以想到另外一种程序结构，那就是try和else在for语句里面构成逻辑分支。当你试着做某件事的时候，try，如果正常则执行else字句然后break，如果发生某个异常则执行异常中的字句，就是try里面的内容不被执行。这有点反常规，但联系实际生活，我们确实也存在这样的逻辑，那就是假想如何如何，发生错误不行则执行else字句，就是假想try里面的内容不实际执行。

### in语句

in语句对于可迭代对象都可以做出是否某个元素包含在某个对象之中的判断。

    >>> 'a' in ['a',1,2]
    True
    >>> dict
    {'a': 1, 'c': 2, 'b': 3, 'd': 4}
    >>> 'e' in dict
    False
    >>> '2' in dict
    False

从上面例子可以看到，一般的列表判断元素是否存在和我们之前预料的一致，关于字典需要说的就是in语句，不判断值。

## for迭代语句

一般有内部重复操作的程序可以先考虑for迭代结构实现，实在不行才考虑while循环结构，毕竟简单更美更安全。

python的for迭代语句有点类似lisp语言的dolist和dotimes函数，具体例子如下：

    for x in 'abc':
        print(x)
    
    a
    b
    c

in后面跟的是**序列**类型，也就是字符串，列表，数组都是可以的。这个语句可以看作先执行x='a'或者类似的匹配赋值操作，然后执行缩进的区块，后面依次类推。（所以for语句也支持序列解包赋值，请参看：[11.5.1](#sec:序列解包赋值){reference-type="ref"
reference="sec:序列解包赋值"}）

### else分句

    for x in 'abc':
        if x == 'b':
            print(x)
            break
    else:
        print('test')

for语句加上else分句这种形式，如果for迭代完了就会执行else分句。但如果for语句还在迭代过程中，break或者return出来了，那么else分句将不会被执行。

### range函数

range函数常和for迭代语句一起使用，其返回一个可迭代对象。

    range(1,10,2)

range函数的用法如上，表示从1开始到10，步长为2，如果用list函数将其包裹，将会输出\[1,3,5,7,9\]。如果不考虑步长的话，这个range函数就有点类似于在序列调出多个值那一小节[9.3.3](#sec:调出多个值){reference-type="ref"
reference="sec:调出多个值"}谈论的区间的情况。所以range(10)就可以看作\[0,10)，range(1,10)就可以看作\[1,10)。但是在这里再加上步长的概念和区间的概念又有所不同了。

    for x in range(-10,-20,-3):
        print(x)
    
    -10
    -13
    -16
    -19

上面例子还演示了range的负数概念，这里如果用区间概念来考察的话，是不能理解的，之所以行得通，是因为它的步长是负数，如果不是负数，那么情况就会和之前讨论的结果类似，将是一个空值。

### 迭代加上操作

迭代产生信息流并经过某些操作之后生成目标序列，更多内容请参见列表解析一节[9.5.11](#sec:列表解析){reference-type="ref"
reference="sec:列表解析"}。

    >>> squares=[x**2 for x in [1,2,3,4,5]]
    >>> squares
    [1, 4, 9, 16, 25]

### enumerate函数

enumerate函数返回一个enumerate对象，这个对象将偏移值和元素组合起来，成为一个可迭代对象了。

    >>> enu = enumerate('abcd')
    >>> [i for i in enu]
    [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]

## while循环

while语句用法和大多数编程语言类似，就是条件控制，循环结构。

    while test:
        do something
    else :
        do something

值得一提的是else语句和while语句属于一个整体，通常情况下while执行完了然后执行下面的语句似乎不需要加上else来控制[^8]。不过else语句的一个功用就是如果while循环的时候遇到break那么else语句也不会执行而是直接跳过去了，见下面。

### break命令

break跳出最近的while或者for循环结构。前面谈到了else和while语句构成一个整体的时候，break可以跳过else语句。

### continue命令

continue命令接下来的循环结构的执行区块将不执行了，跳到条件判断那里看看是不是继续循环。如果是，那么继续循环。同样在for语句中continue命令的意思也是一样的。

### pass命令

pass命令就是什么都不做。pass命令即可用于循环语句也可用于条件语句。

pass命令什么都不做似乎没有什么意义，不过作为一个空占位符还是很有用的。比如你编写一个大型的GUI程序，信号－槽机制都构思好了，只是对应的函数暂时还没写好，这个时候你可以将对应的函数，只是空的函数名加上pass语句写上，这样整个程序就可以继续边编写边调试了。

