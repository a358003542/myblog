Title: 让一个函数成为装饰器的装饰器函数
Date: 2018-04-15
Tags: python,

[TOC]


python中的装饰器的作用就是可调用对象（一般情况下指函数）名字的重绑定。重绑定行为通常发生在原函数def结束之后，原函数将作为参数被传入装饰器函数中，从而实现函数行为上的重制。

所以装饰器函数的最基本定义就是接受一个可调用对象再返回一个可调用对象。

本文的任务就是让一个函数成为装饰器的装饰器，这在某些情况下是有用的，比如说

```
    def post(self):
        pass
```
在flask中我们定义的视图函数，如果需要添加参数检查逻辑，那么大概我们会写一系列的验证函数，将post进来的参数 ----> ----> ----> 一直传过去，直到传出来那么就说明参数都没有问题的，嗯，很直观的一种设计模式。

要实现这种代码风格，就需要做到让一个或者一些函数成为装饰器，而为了代码复用，最好写出一个装饰器函数装饰目标函数即可。

我们知道装饰器最直观的写法如下：
```
def build_passing_decorator_func(func):
    """
    使一个函数成为一个装饰器
    """
    def wrapper(method, *args, **kwargs):
        ok, response = method(*args, **kwargs)
        return func(ok, response)

    return wrapper
```
```
@build_passing_decorator_func
def test(ok, data):
    pass
```
```
@test
def post(self):
    pass
```

按照装饰器的含义，我们有：
```
test(post)(self)
build_passing_decorator_func(test)(post)(self)
wrapper(post)(self)  # func=test
```
最后程序似乎执行的是：
```
ok, response = post(*args, **kwargs)
return test(ok, response)
```
如果这个test方法返回的还是某种参数格式，那么多个装饰器可以一直这样写下去。

**但是上面的这种写法有个问题** ：

如果装饰的是简单的函数，那么是没问题的，但如果装饰的是类的方法的话，self实例并不能很好的解析。参考 Mark Lutz 的python学习手册一书，按照上面的写法，装饰的方法会重绑定到装饰器类中，从而丢失了self本身的实例，导致self不能正常解析。

但如果采用下面这种嵌套函数写法则不会有如上问题：

```
def build_passing_decorator_func(func):
    """
    使一个函数成为一个装饰器
    """
    def wrapper(f):
        @wraps(f)
        def decorator(*args, **kwargs):
            ok, response = f(*args, **kwargs)
            return func(ok, response)
        return decorator
    return wrapper
```
具体原因我还不是特别清楚，之前我想到是可能python里的装饰器优先级特别高，先于类的实例化就已经加载了，而这种嵌套函数有惰性解析参数的含义，所以类的实例化self解析才不会出错。
