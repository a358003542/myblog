Title: python语言学习之-官方模块第三谈
Slug: python-modules-three
Date: 2017-05-10

[TOC]





re模块 
------

re模块提供了python对于正则表达式的支持，对于字符串操作，如果之前在介绍字符串类型的一些方法（比如split，replace等等），能够用它们解决问题就用它们，因为更快更简单。实在需要动用正则表达式理念才考虑使用re模块，而且你要克制写很多或者很复杂的（除非某些特殊情况）正则表达式的冲动，因为正则表达式的引入将会使得整个程序都更加难懂和不可捉摸。

更多内容请参见[官方文档](https://docs.python.org/3/library/re.html)。

### re模块中的元字符集

*.*

:   表示一行内的任意字符，如果如果通过re.compile指定**re.DOTALL**，则表示多行内的任意字符，即包括了换行符。此外还可以通过字符串模板在它的前面加上**(?s)**来获得同样的效果。

*\**

:   对之前的字符匹配或者多次。

*+*

:   对之前的字符匹配或者多次。

*?*

:   对之前的字符匹配或者。

*{m}*

:   对之前的字符匹配()m次。

*{m,n}*

:   对之前的字符匹配m次到n次，其中n次可能省略，视作默认值是无穷大。

*\^*

:   表示字符串的开始，如果加上**re.MULTILINE**选项，则表示行首。此外字符串模板加上**(?m)**可以获得同样的效果。

*\$*

:   表示字符串的结束，同\^类似，如果加上**re.MULTILINE**选项，则表示行尾，可以简单理解为`\n`换行符。此外字符串模板加上**(?m)**可以获得同样的效果。

    \$符号在re.sub函数中可以被替换为另外一个字符串，其具体效果就是原字符串尾加上了这个字符串，类似的\^被替换成某个字符串，其具体效果就是原字符串头加上了这个字符串。这里显然\^和\$在字符串中都不是真实存在的字符，而没有这个所谓的标记，所以这种替换总给人怪怪的感觉。

*\[\]*

:   \[abc\]字符组匹配一个字符，这个字符是a或者b或者c。类似的\[a-z\]匹配所有的小写字母，`[\w]`匹配任意的字母或数字，具体请看下面的特殊字符类。

*\|*

:   相当于正则表达式内的匹配或逻辑。

*()*

:   圆括号包围的部分将会记忆起来，方便后面调用。这个后面在谈及。

### re模块中的特殊字符类

    \w  任意的字母或数字  [a-zA-Z0-9_]  (meaning word)
    \W  匹配任何非字母非数字 [^a-zA-Z0-9_]
    \d   [0-9]   (digit) 数字
    \D  [^0-9] 非数字
    \s   匹配任何空白字符   [ \t\n\r\f\v] 。
    \S  匹配任何非空白字符
    匹配中文:[\u4e00-\u9fa5]
    \b  文档说严格的定义是\w 和\W 之间的边界，反之亦然。粗略的理解可以看作是英文单词头或者尾。

其中\^在方括号\[\]里面，只有在最前面，才表示排除型字符组的意思。

### 转义问题

正则表达式的转义问题有时会比较纠结。一个简单的原则是以上谈及的有特殊作用的字符有转义问题，如果python中的字符都写成`r''`这种形式，也就是所谓的raw
string形式，这样`\n`在里面就可以直接写成`\n`，而`\section`可以简单写为`\\section`即可，也就是`\`字符需要转义一次。

然后字符组的方括号内\[\]有些字符有时是不需要转义的，这个实在不确定就转义吧，要不就用正则表达式工具测试一下。

### re模块的使用

compile方法生成regular expression
object这一条线这里略过了，接下来的讨论全部基于（原始的）字符串模板。

字符串模板前面提及(?m)和(?s)的用法了，然后**(?i)**表示忽略大小写。

#### 匹配和查找

search，match方法简单地用法就是：

    re.search(字符串模板, 待匹配字符串)
    re.match(pattern, string)

它们将会返回一个match object或者none，其中match
object在逻辑上就是真值的意思。match对字符串的匹配是必须从一开始就精确匹配，这对于正则表达式多少0有点突兀。推荐使用search方法，如果一定要限定行首，或者字符串开始可以用前面讨论的正则表达式各个符号来表达。请看下面的例子。

    import re
    string = '''this is test line.
    this is the second line.
    today is sunday.'''
    
    match = re.search('(?m)^today',string)
    
    if match:
        print('所使用的正则表达式是：',match.re)
        print('所输入的字符串是：',match.string)
        print('匹配的结果是：',match.group(0))
        print('匹配的字符串index',match.span())
    else:
        print('return the none value')

前面说道圆括号的部分将会记忆起来，作为匹配的结果，默认整个正则表达式所匹配的全部是group中的第0个元素，然后从左到右，子group编号依次是1，2，3\...\...。

    所使用的正则表达式是： re.compile('(?m)^today', re.MULTILINE)
    所输入的字符串是： this is test line.
    this is the second line.
    today is sunday.
    匹配的结果是： today
    匹配的字符串index (44, 49)

具体这些信息是为了说明情况，实际最简单的情况可能就需要判断一下是不是真值，字符串模板是不是匹配到了即可。

#### 分割操作

re模块的split函数可以看作字符串的split方法的升级版本，对于所描述的任何正则表达式，匹配成功之后都将成为一个分隔符，从而将原输入字符串分割开来。

下面是我写的zwc小脚本的最核心的部分，用途是统计中英文文档的具体英文单词和中文字符的个数。其中最核心的部分就是用的re的split函数进行正则表达式分割，如果不用那个圆括号的话，那么分隔符是不会包含进去的，这里就是具体匹配的中文字和各个标点符号等等。用了圆括号，那么圆括号匹配的内容也会进去列表。这里就是具体的各个分隔符。

    import re
    
    def zwc(string):
        #中英文常用标点符号
        lst = re.split('([\u4e00-\u9fa5\s，。；])',string)
        #去除 空白
        #去除\s 中英文常用标点符号
        lst = [i for i in lst if not  i in
        [""," ","\n","\t","\r","\f","\v","；","，","。"]]
        print(lst)
    
    if __name__ == '__main__':
        string='''道可道，非常道。名可名，非常名。無名天地之始，有名萬物之母。
        故常無欲，以觀其妙；常有欲，以觀其徼。此兩者同出而異名，
        同謂之玄，玄之又玄，眾妙之門。 '''
        zwc(string)

字符分割之后后面做了一个小修正，将匹配到的空白字符和中英文标点符号等都删除了，这些是不应该统计入字数的。

具体这个github项目链接在这里：[zwc项目](https://github.com/a358003542/zwc)。

#### 替换操作

基于正则表达式的替换操作非常的有用，其实前面的search方法，再加上具体匹配字符串的索引值，然后修改原字符串，然后再search这样循环操作下去，就是一个替换操作了。re模块有sub方法来专门解决这个问题。

#### 非最长匹配

本小节参考了 python cookbook 的 2.7 小节，比如说：

    re.compile(r'"(.*)"')

这将匹配两个双引号之间的内容，其默认是最长匹配，也就是多个双引号组成的句子都会匹配进去，你可以如下要要求最短匹配：

    re.compile(r'"(.*?)"')

#### 非捕获组

看下面的正则表达式， `(?:...)` 这个括号的组是非捕获组，也就是不会进入
.group 里面去。

    re.search(r'((?:.|\n)*)',text2)

然后默认 `.` 是不会匹配换行符号的，如果要引入换行符则要如上所示加上。



## abc模块



abc模块帮助你实现抽象基类，有点类似于java中抽象类的概念。

具体实现如下所示：

```python
from abc import abstractmethod
from abc import ABC 

class Graph(ABC):
    """
    一般图
    """
    DIRECTED = None

    @abstractmethod
    def nodes(self):
        """
        :return:
        """
        raise NotImplementedError("Not Implement nodes methods")

```

抽象类不可实例化，实例化将会报错。继承于它的类，如果如上定义了抽象方法，那么继承它的类必须定义好对应方法的实现，否则将会报错。

抽象类里面也可以定义不是抽象方法的其他实际动作的方法。

抽象类里面还可以定义抽象属性。





argparse模块
------------

下面简要介绍了python3的官方文档argparse模块的用法，用于快速制作一个可以刷参数的python脚本。

首先看下面这个简单的情况:

    import argparse
    usage = '''
    this is a example to show argparse usage
    '''
    parser = argparse.ArgumentParser(usage=usage)
    
    args = parser.parse_args()

这是简单的一个例子了，现在脚本还不可以接受任何参数，只可以用 `-h` 或
`--help` 来查看一些信息，如下所示。

    wanze@wanze-ubuntu64:~/桌面$ python3 hello.py -h
    usage: 
    this is a example to show argparse usage
     [-h]
    
    optional arguments:
      -h, --help  show this help message and exit

其首先是新建一个parser，上面ArgumentParser的usage是可选参数，就是命令行的一些描述信息。然后需要调用parser的
`parse_args` 方法，其就是具体将命令行接受的一些参数刷进去。

### 简单添加一个参数

上面的例子太简单了，现在开始简单添加一个参数。

    import argparse
    usage = '''
    this is a example to show argparse usage
    '''
    parser = argparse.ArgumentParser(usage=usage)
    
    parser.add_argument('--config',help="the config file path")
    
    args = parser.parse_args()
    
    print(args)

这样命令行的帮助信息就变成如下所示了:

    wanze@wanze-ubuntu64:~/桌面$ python3 hello.py -h
    usage: 
    this is a example to show argparse usage
    
    optional arguments:
      -h, --help       show this help message and exit
      --config CONFIG  the config file path

如果我们如下输入则有:

    wanze@wanze-ubuntu64:~/桌面$ python3 hello.py --config='config.cfg'
    Namespace(config='config.cfg')

我们看到 `parse_args` 方法返回的是Namespace对象，推荐用 `vars`
函数来将其处理成为字典值，这样会更好地方便后面的使用。

    import argparse
    usage = '''
    this is a example to show argparse usage
    '''
    parser = argparse.ArgumentParser(usage=usage)
    parser.add_argument('-c','--config',help="the config file path")
    args = vars(parser.parse_args())
    
    print(args)
    
    wanze@wanze-ubuntu64:~/桌面$ python3 hello.py -h
    usage: 
    this is a example to show argparse usage
    python3 hello.py
    
    optional arguments:
      -h, --help            show this help message and exit
      -c CONFIG, --config CONFIG
                            the config file path
    wanze@wanze-ubuntu64:~/桌面$ python3 hello.py --config='config.cfg'
    {'config': 'config.cfg'}

上面代码稍作修改，在长名字可选参数前面还可以加上短名字可选参数支持，然后我们看到
`parse_args` 方法经过 `vars`
处理之后返回的是字典值。该字典的key默认对应的是长名字可选参数。你还可以自己设置目标参数名:

### 添加参数的其他选项设置

下面演示了如何设置目标参数在脚本中具体对应的变量名:

    import argparse
    usage = '''
    this is a example to show argparse usage
    '''
    parser = argparse.ArgumentParser(usage=usage)
    parser.add_argument('-c','--config',dest="configpath",help="the config file path")
    args = vars(parser.parse_args())
    
    print(args)

然后我们看到字典输入如下:

    wanze@wanze-ubuntu64:~/桌面$ python3 hello.py --config='config.cfg'
    {'configpath': 'config.cfg'}

当然一般就默认设置成为和长名字可选参数一致，没必要这么折腾。类似的你还可以继续用
`add_argument` 方法来添加其他的可选参数，然后 `add_argument`
还有如下一些选项配置:

required=True

:   该参数一定要输入值，否则报错

help

:   描述信息，前面已经看到了。

default

:   该参数的默认值，默认是None，你可以选择设置成另外一个值。

type

:   目标参数的数据类型，默认是字符串，可以设置为int或float。注意设置格式如下，不是字符串的那种设置形式:
​    `parser.add_argument('--delay',type=int)`

必填参数的添加如下所示，除了这个\"target\"名字前面没有 `--`
之外，和可选参数用法大致类似，其刷入args字典之后的key就是\"target\"这个名字。

    parser.add_argument('target',help="必填参数")

不过必填参数和可选参数在某些细节上还是有点差异的，后面会提及。

#### nargs选项设置

nargs设置之后该参数在脚本中具体对应的变量将是一个列表。其中nargs可以设置为一个数字，比如
`nargs=4` ，则脚本对该参数将接受4个输入值，然后将其收集进一个列表里面。

此外还有:

nargs='\*'

:   这通常是对可选参数进行设置，当然也可以作用于必填参数，但这让必填参数失去意义了。其将收集任意多的输入参数值，而如果多个可选参数之间这样使用星号是可以的，具体请参看官方文档。

nargs='+'

:   这通常作用于必填参数，其意义有点类似于正则表达式里面的'+'号，和上面的'\*'号比起来其必须有一个输入值，否则将报错。

nargs='?'

:   这个'?'号具体使用情况挺复杂的，我不太喜欢，而且其和nargs其他的一些设置比较起来显得有点格格不入。首先其对应的变量值不是列表而是单个值！其次其改变了默认值的行为。如果该参数不输入，比如
​    `--foo`
​    这个东西完全不输入在命令行里面，那么foo默认取default的值，如果加入了
​    `--foo` 这个东西但是后面又不跟值，则foo取 **const**
​    选项赋的值。不太喜欢这个东西。

### 一个完整的例子

下面给出一个完整的例子:

    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    import argparse
    usage = '''
    resize the image
    '''
    
    def main():
        parser = argparse.ArgumentParser(usage=usage)
        parser.add_argument('-c','--config',dest="configpath",help="the config file path")
        parser.add_argument('inputimg',help="the input image",nargs='+')
        parser.add_argument('--width',help="the input image",type=int)
    
        args = vars(parser.parse_args())
    
        configpath = args['configpath']
        width = args['width']
        inputimg = args['inputimg']
    
        for inputimg in args['inputimg']:
            print('resize image')
            print('the input image is {}'.format(inputimg))
            print('the target width is {}'.format(width))


    if __name__ == '__main__':
        main()

具体运行情况如下所示:

    wanze@wanze-ubuntu64:~/图片$ python3 resizeimg.py --help
    usage: 
    resize the image
    
    positional arguments:
      inputimg              the input image
    
    optional arguments:
      -h, --help            show this help message and exit
      -c CONFIGPATH, --config CONFIGPATH
                            the config file path
      --width WIDTH         the input image
    
    wanze@wanze-ubuntu64:~/图片$ python3 resizeimg.py --width=300 *.png
    resize image
    the input image is 2015-01-27 13:16:46 的屏幕截图.png
    the target width is 300
    resize image
    the input image is 2015-05-03 18:17:19屏幕截图.png
    the target width is 300
    resize image
    the input image is 2015-05-03 18:20:45屏幕截图.png
    the target width is 300
    ....

### 命令行选项关联其他动作

parser的 `add_argument` 方法的 `action`
参数就是用来控制命令行选项关联的动作的，一般都不需要设置，就是默认的
`store` ，也就是存储值。类似的有 `store_const` , `store_true` 和
`store_false` 。

#### store\_const

如果是默认的store，则通常是需要指明具体值的，如果设置action为
`store_const` 了:

    parser.add_argument('--foo', action='store_const', const=42)

那么如下就会自动设置该值，这和default默认值的区别是这个选项的值要求是某个常量值。

    >> python3 test2.py --foo
    Namespace(foo=42)

#### store\_true 和 store\_false

如果写为:

    parser.add_argument('--foo', action='store_true')

则其存储的就是 `True` 值:

    >> python3 test2.py --foo 
    Namespace(foo=True)

这里主要是要讲定义自己的动作，就是类似 `--version`
这样的用法，是一种影响程序整个工作流的选项，官方文档推荐通过子类化
`argparse.Action` 的方法，还是有点麻烦的。然后发现 *click*
模块非常好（一个解决创建命令行脚本工具问题推荐使用的第三方模块），处理这个问题也很容易:

    import click
    
    def print_version(ctx, param, value):
        if not value or ctx.resilient_parsing:
            return
        click.echo('Version 1.0')
        ctx.exit()
    
    def quick(ctx,param,value):
        print(ctx,param,value)
        ctx.exit()
    
    @click.command()
    @click.option('--version', is_flag=True, callback=print_version,
                  expose_value=False, is_eager=True)
    @click.option('--quick',callback=quick,is_flag=True)
    def hello():
        while True:
            userinput = input('input:')
            click.echo(userinput)
    
            if userinput == 'exit':
                break


    if __name__ == '__main__':
        hello()

这里的ctx和param到click模块那边再细讲吧，我们看到整个过程比argparse美观多了。





ast模块
-------

更多信息请参看 [官方文档](https://docs.python.org/3.4/library/ast.html)
。

### literal\_eval函数

`literal_eval`函数是一个非常有用的函数，其可用于将某个短小的python字符串转化成python
object。如下所示:

    import ast
    def str2pyobj(val):
        '''str to python obj or not changed'''
        try:
            val = ast.literal_eval(val)
        except Exception:###
            pass
        return val

支持的python object有: strings, bytes, numbers, tuples, lists, dicts,
sets, booleans, and None.

所以一般的字符串如 \"1\" \"3.14\" \"\[1,2,3\]\" 将其分别转化成为integer
float
和list是小菜一碟。当然最好建立异常捕捉，如果转化失败，则原样返回字符串即可。





collections模块
---------------

更多内容请参见[官方文档](https://docs.python.org/3/library/collections.html)。

### namedtuple函数

collections模块里面的namedtuple函数将会产生一个有名字的数组的类（有名数组），通过这个类可以新建类似的实例。比如：

    from collections import namedtuple
    
    Point3d=namedtuple('Point3d',['x','y','z'])
    p1=Point3d(0,1,2)
    print(p1)
    print(p1[0],p1.z)
    
    Point3d(x=0, y=1, z=2)
    0 2

### Counter计数类

可以进行简单的输入数据统计频数计算。

### OrderedDict对象

python中的字典对象默认各个key是没有顺序的，OrderdDict对象的概念就是在字典概念的基础上让各个key有顺序。

一个例子如下所示（来自官方文档）。简单的理解就是一个字典对象记住了各个key的插入顺序。

    >>> d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}
    
    >>> # dictionary sorted by key
    >>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))
    OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])
    
    >>> # dictionary sorted by value
    >>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))
    OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
    
    >>> # dictionary sorted by length of the key string
    >>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
    OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])




configparser模块
----------------

简单的配置文件管理就用python的内置模块configparser。python2对应的模块名字叫
ConfigParser 。

python3之后configparser的使用更加简单了，具体就分为如下几步:

### 新建一个configparser对象

    import configparser
    config = configparser.ConfigParser()

### 读取某个config文件

调用read方法具体读取某个config文件。

    config.read('test.cfg')

### 如同字典一般操作configparser对象

然后接下来就是如同字典一般操作这个configparser对象。其中 'DEFAULT'
是特殊的section，大致如下这样表达:

    config['DEFAULT'] = {'ServerAliveInterval': '45',
                         'Compression': 'yes',
                         'CompressionLevel': '9'}
    config['bitbucket.org'] = {}
    config['bitbucket.org']['User'] = 'hg'
    config['topsecret.server.com'] = {}

### 调用write方法写入

    with open('example.ini', 'w') as configfile:
        config.write(configfile)

### 不默认更改大小写

具体请参看
[这个网页](http://stackoverflow.com/questions/19359556/configparser-reads-capital-keys-and-make-them-lower-case)
，configparser模块默认把 option name 也就是每个section的key
name改成小写，我不太喜欢这种风格，因为将configparser刷成字典值时，我们通常认为字典的key大小写是区分的，可以如下改动，然后就不自动进行小写操作了:

    self.cfg = configparser.ConfigParser()
    self.cfg.optionxform = str## not auto make it lowercase


## csv模块

Title: csv模块
Slug: cvs-module
Date: 2017-11-24 12:05
Modified: 2017-11-24 12:05
Tags: python

[TOC]

本文主要讨论python内置模块csv略显高级的知识，也就是自定义csv的方言。



## 自定义csv方言

首先我们看到最通用的excel格式的csv方言写法：

```python
class excel(Dialect):
    """Describe the usual properties of Excel-generated CSV files."""
    delimiter = ','
    quotechar = '"'
    doublequote = True
    skipinitialspace = False
    lineterminator = '\r\n'
    quoting = QUOTE_MINIMAL
register_dialect("excel", excel)
```

下面就这些字段的含义作出说明：

- **delimiter**  分隔符，这个意义很明显。

- **lineterminator**  换行符，这个意义也很明显，目前主要就两种： `\r\n`  和 `\n` 。

- **skipinitialspace**  默认是False，其主要是对于如果你将空格设置为分隔符时有意义，这样后面字符开始的空格将会被忽略，其他情况设置为True或者False区别不大。

    ---

- **quoting**  设置quote规则

    - csv.QUOTE_MINIMAL 意思是只有在需要的情况下才加上双引号，比如逗号在字符串里面，双引号在字符串里面，换行符号在字符串里面等等。

    - csv.QUOTE_ALL 意思是都加上双引号，即使是数字。

    - csv.QUOTE_NONNUMERIC 数字不加，字符串都加上双引号。（只有在这种情况下csv模块才会正确将数字解析为float类型）

    - csv.QUOTE_NONE 都不加（此时需要设置好escapechar选项）

- **quotechar** 设置quote具体的字符，一般设置为双引号。

- **doublequote** 用来处理双引号在字符串中的情况，默认是True，字符串将会双引号之外再加上双引号，如果设置为False，会前面加上一个 `escapechar` 。


自己定义csv方言就是类似的写上这样一个方言类，然后如下注册好即可：

```
import csv

class MindMapCSV(csv.Dialect):
    delimiter = ',' # 分隔符
    quotechar = '"' # quote符号
    doublequote = True # 双引号在字符中的情况
    skipinitialspace = True # 分隔符后空白忽略
    lineterminator = '\n' # 换行符
    quoting = csv.QUOTE_MINIMAL # 最小quote

csv.register_dialect("MindMapCSV", MindMapCSV)
```



## 对应的Reader编写

下面贴出一个样例，具体要看你设计的csv方言来的。

```python
class Reader():
    def __init__(self,f,dialect='sv'):
        self.lines = []
        for line in csv.reader(f, dialect):
            line = [self.to_float(e) for e in line]
            self.lines.append(line)

    def getrow(self,num):
        return self.lines[num-1]

    def getcol(self,head):
        index = self.getrow(1).index(head)
        lst = []
        for line in self.lines:
            lst.append(line[index])
        return lst

    def getdata(self):
        return self.lines

    @staticmethod
    def to_float(e):
        try:
            return float(e)
        except ValueError:
            return e
```

其中有：

-   getrow 取某一行的值
-   getcol 取某一列的值
-   getdata 取整个表格的数据值

## 对应的Writer编写

同样也要根据你的csv方言设计来的，下面只是贴出一个样例：

```python
class Writer():
    def __init__(self,f,dialect='sv'):
        self.lines = []
        self.writer = csv.writer(f, dialect)

    def addrow(self,row):
        self.lines.append(row)

    def addcol(self,col):
        for index in range(len(self.lines)):
            self.lines[index].append(col[index])

    def setrow(self,num,row):
        self.lines[num-1] = row
    def setcol(self,num,col):
        for index in range(len(self.lines)):
            self.lines[index][num-1] = col[index]

    def set(self,row,col,e):
        self.lines[row-1][col-1] = e

    def setdata(self,data):
        self.lines = data

    def write(self):
        for line in self.lines:
            self.writer.writerow(line)
```

提供的方法有：

-   addrow 添加一行值
-   addcol 添加一列值
-   set 设置某行某列的某个值为什么
-   setdata 设置整个数据
-   write 实际写入到文件中去。





## tempfile模块

tempfile模块用于创建临时文件或者临时文件夹，这个模块在所有系统平台上都能正常工作，有时还是很有用的。

比如windows系统下的临时文件夹所在：
```python
>>> import os
>>> os.name
'nt'
>>> import tempfile
>>> tempfile.gettempdir()
'C:\\Users\\a3580\\AppData\\Local\\Temp'
```
最核心的两个函数是 `mkstemp` 和 `mkdtemp` 。



## mkstemp

mkstemp函数用于新建一个临时文件

```python
fd, fpath = tempfile.mkstemp(dir=tmpdir)
with os.fdopen(fd, 'wb') as temp_cache_file:
    marshal.dump((self.FREQ, self.total), temp_cache_file)
```

返回的第二个参数就是目标临时文件的路径名，第一个文件参数比较特殊，是操作系统级别的文件句柄（应该是C语言那边的文件句柄吧），要转成一般使用的python文件对象如上所示，使用 `os.fdopen` 来打开。