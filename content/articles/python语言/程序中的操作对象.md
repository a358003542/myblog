Title: python语言学习之-程序中的操作对象
Slug: python-talk-two
Date: 2016-02-01
Modified: 2018-10-03

[TOC]



python和c语言不同，c 是什么 `int x = 3`
，也就是这个变量是整数啊，字符啊什么的都要明确指定，python不需要这样做，只需要声明
`x ＝ 3`
即可。但是我们知道任何程序语言它到最后必然要明确某一个变量（这里也包括后面的更加复杂的各个结构对象）的内存分配，只是python语言帮我们将这些工作做了，所以就让我们省下这份心吧。

    ''' 这是一个多行注释
        你可以在这里写上很多废话
        '''
    x = 10
    print(x,type(x))

python程序由各个模块（modules）组成，模块就是各个文件。模块由声明（statements）组成，声明由表达式（expressions）组成，表达式负责创造和操作对象（objects）。在python中一切皆对象。python语言内置对象（数值、字符串、列表、数组、字典、文件、集合、其他内置对象。）后面会详细说明之。

## 赋值

python中的赋值语法非常的简单，x=1，就是一个赋值语句了。和c语言不同，c是必须先声明int
x之类，开辟一个内存空间，然后才能给这个x赋值。而python的x=1语句实际上至少完成了三个工作：一，判断1的类型（动态类型语言必须要这步）；二，把这个类型的对象存储在内存里面；三，创建x这个名字和这个名字指向这个内存，x似乎可以称之为对应c语言的指针对象。

### 序列赋值

    x,y=1,'a'
    [z,w]=['b',10]
    print(x,y,z,w)
    
    1 a b 10
    >>> 

我们记得python中表达式可以加上圆括号，所以这里`x,y`产生的是一个数组`(x,y)`，然后是对应的数组平行赋值，第二行是列表的平行赋值。这是一个很有用的技巧。

在其他语言里面常常会介绍swap函数，就是接受两个参数然后将这两个参数的值交换一下，交换过程通常要用到临时变量。而在python中不需要再创建一个临时变量了，因为序列赋值会自动生成一个临时的右边的序列（其中的变量都对应原来的原始值），然后再赋值（这里强调一一对应是指两边的序列长度要一致。）

#### 交换两个元素

在python中交换两个元素用序列赋值形式是很便捷的：

    >>> x = 1
    >>> y = 2
    >>> x,y = y,x
    >>> print(x,y)
    2 1

这个过程显然不是先执行x=y然后执行y=x，如上所述的，程序首先右边创建一个临时的序列，其中的变量都对应原来的值，即`x,y=(2,1)`，然后再进行序列赋值。

### 同时赋相同的值

    x=y='a'
    z=w=2
    print(x,y,z,w)
    
    a a 2 2
    >>> 

这种语句形式c语言里面也有，不过内部实现机制就非常的不一样了。python当声明x=y的时候，x和y是相同的指针值，然后相同的指针值都指向了'a'这个字符串对象，也可以说x和y就是一个东西，只是取的名字不同罢了。

我们用is语句[^2]来测试，显示x和y就是一个东西。

    >>> x=y='a'
    >>> x is y
    True
    >>> x == y
    True

但如果写成这种形式：

    >>> x = 'a'
    >>> y = 'a'
    >>> x is y
    True

x和y还是指向的同一个对象，关于这点python内部是如何实现的我还不太清楚（似乎有点神奇）。为了说明is语句功能正常这里再举个例子吧：

    >>> x = [1,2,3]
    >>> y = [1,2,3]
    >>> x == y
    True
    >>> x is y
    False

我们看到这里就有了两个列表对象。

### 增强赋值语句

x=x+y可以写作x += y。类似的还有：

   +=    &=    \>\>=
----- ----- -------
   -=    \|=   \<\<=
   \*=   \^=   \*\*=
   /=    \%=    //=

#### 序列解包赋值



### 可迭代对象的迭代赋值

在我们对python语言有了深入的了解之后，我们发现python中迭代思想是深入骨髓的。我们在前面接触了序列的赋值模式之后，发现似乎这种赋值除了临时创建右边的序列之外，还似乎与迭代操作有关，于是我们推测python的这种平行赋值模式可以扩展到可迭代对象，然后我们发现确实如此！

    >>> x,y,z= map(lambda x : x+2,[-1,0,1])
    >>> print(x,y,z)
    1 2 3

最后要强调一点的是确保左边的变量数目和后面的可迭代对象的输出元素数目是一致的，当然进一步扩展的序列解包赋值也是支持的：

    >>> x,y,*z= map(lambda x : x+2,[-1,0,1,2])
    >>> print(x,y,z)
    1 2 [3, 4]

通配赋值，我喜欢这样称呼，通配之后收集的元素在列表里面；而函数参数的通配传递，收集的元素是在元组里面。

最后我们总结到，可迭代对象的赋值就是迭代操作加上各个元素的一对一的赋值操作。

## 数值

python的数值的内置类型有：int，float，complex等[^3]。\
python的基本算术运算操作有加减乘除（+ - \*
/）。然后'='表示赋值，类似数学书上的中缀表达式和优先级和括号法则等，这些都是一般编程语言说到烂的东西了。

    print((1+2)*(10-5)/2)
    print(2**100)

### 二进制八进制十六进制

二进制的数字以0b（零比）开头，八进制的数字以0o（零哦）开头，十六进制的数字以0x（零艾克斯）开头。

    0b101010, 0o177, 0x9ff

以二进制格式查看数字使用bin命令，以十六进制查看数字使用hex命令。

    >>> bin(42)
    '0b101010'
    >>> hex(42)
    '0x2a'

#### 进制转换小程序

    number=input("请输入一个数字：")
    number= eval(number)
    #
    radix= input('''请输入你想转换的进制系统
    2   表示  二进制
    8   表示  八进制
    16  表示  十六进制
    ''')
    radix =eval(radix)
    
    while True:
        if radix == 2:
            print(bin(number))
            break
        elif radix == 8:
            print(oct(number))
            break
        elif radix == 16:
            print(hex(number))
            break
        else:
            print("sorry you input the wrong radix")

程序运行的情况如下所示：

    请输入一个数字：20
    请输入你想转换的进制系统
    2   表示  二进制
    8   表示  八进制
    16  表示  十六进制
    8
    0o24

此外基于字符串的进制转换可以用字符串的format方法来处理之。

### 数学幂方运算

$x^y$，x的y次方如上面第二行所述就是用`x**y`这样的形式即可。此外pow函数作用是一样的，`pow(x,y)`。

### 数值比较

数值比较除了之前提及的\>，\<，==之外，\>=，\<=，!=也是有的（大于等于，小于等于，不等于）。此外python还支持连续比较，就是数学格式$a<x<b$，x在区间$(a,b)$的判断。在python中可以直接写成如下形式：`a<x<b`。这实际实现的过程就是两个比较操作的进一步与操作。

### 相除取商或余

就作为正整数相除使用 `x//y`
得到的值意义还是很明显的就是**商**。带上负号感觉有点怪了，这里先略过。相关的还有**取余**数，就是`x%y`，这样就得到x除以y之后的余数了，同样带上负号情况有变，这里先略过。

### 复数

python直接支持复数，
复数的写法是类似`1+2j`这样的形式，然后如果z被赋值了一个复数，这样它就是一个复数类型，那么这个类具有两个属性量，**real**和**imag**。也就是使用`z.real`就给出这个复数的实数部。imag是imaginary
number的缩写，虚数，想像出来的数。

### abs函数

大家都知道abs函数是绝对值函数，这个python自带的，不需要加载什么模块。作用于复数也是可以的：

    z=3+4j
    print(z.real,z.imag)
    print(abs(z))

这个和数学中复数绝对值的定义完全一致，也就是复数的模：
$\left| z \right| =\sqrt { a^{ 2 }+b^{ 2 } }$

### round函数

简单的理解就是这个函数实现了对数值的功能。

    >>> round(3.1415926)
    3
    >>> round(3.1415926,0)
    3.0
    >>> round(3.1415926,1)
    3.1
    >>> round(3.1415926,2)
    3.14
    >>> round(3.1415926,4)
    3.1416

这里第二个参数接受0或者负数多少有点没意义了，一般使用还是取1或大于1的数吧，意思就是保留几位小数。

### min，max和sum函数

min，max函数的用法和sum的用法稍微有点差异，简单起见可以认为min，max，sum都接受一个元组或者列表（还有其他？），然后返回这个元组或者列表其中的最小值，最大值或者相加总和。此外min和max还支持min(1,2,3)这样的形式，而sum不支持。

    >>> min((1,6,8,3,4))
    1
    >>> max([1,6,8,3,4])
    8
    >>> sum([1,6,8,3,4])
    22
    >>> min(1,6,8,3,4)
    1

### 位操作

python支持位操作的，这里简单说一下：位左移操作\<\<，位与操作&，位或操作\|，位异或操作\^。

    >>> x=0b0001
    >>> bin(x << 2)
    '0b100'
    >>> bin(x | 0b010)
    '0b11'
    >>> bin(x & 0b1)
    '0b1'
    >>> bin(x ^ 0b101)
    '0b100'

### math模块

在`from math import *`之后，可以直接用符号pi和e来引用圆周率和自然常数。此外math模块还提供了很多数学函数，比如：

sqrt

:   开平方根函数，sqrt(x)。

sin

:   正弦函数，类似的还有cos，tan等，sin(x)。

degrees

:   将弧度转化为角度，三角函数默认输入的是弧度值。

radians

:   将角度转化位弧度，radians(30)。

log

:   开对数，log(x,y)，即$\log_y x$，y默认是e。

exp

:   指数函数，exp(x)。

pow

:   扩展了内置方法，现在支持float了。pow(x,y)

这里简单写个例子：

    >>> from math import *
    >>> print(pi)
    3.141592653589793
    >>> print(sqrt(85))
    9.219544457292887
    >>> print(round(sin(radians(30)),1))#sin(30°)
    0.5

更多内容请参见[官方文档](http://docs.python.org/3.4/library/math.html)。

### random模块

random模块提供了一些函数来解决随机数问题。

random

:   random函数产生0到1之间的随机实数（包括0）。\
​    random()-\>\[0.0, 1.0)。

uniform

:   uniform函数产生从a到b之间的随机实数（a，b的值指定，包括a。）。\
​    uniform(a,b)-\>\[a.0, b.0)。

randint

:   randint函数产生从a到b之间的随机整数，包含a和b。\
​    randint(a,b)-\>\[a,b\]

choice

:   choice随机从一个列表或者字符串中取出一个元素。

randrange

:   randrange函数产生从a到b之间的随机整数，步长为c（a，b，c的值指定，相当于choice(range(a,b,c))。整数之间就用randint函数吧，这里函数主要是针对range函数按照步长从而生成一些整数序列的情况。

sample(p,k)

:   sample函数从p中随机选取唯一的元素（p一般是range(n)或集合之类的，这里所谓的唯一的意思就是不放回抽样的意思，但如果p样品里面有重复的元素，最后生成的列表还是会有重复的元素的。）然后组成k长度的列表返回。

下面是一个简单的例子：

    >>> from random import *
    >>> print(random())
    0.36882919781549717
    >>> print(uniform(1,10))
    2.771065174892699
    >>> print(randrange(1,6))
    1
    >>> print(randint(1,10))
    3
    >>> print(choice('abcdefghij'))
    j
    >>> print(choice(['1','2','3']))
    2

作为随机实数，所谓开始包含的那个临界值可能数学意义大于实际价值，你可以写一个类似下面的小脚本看一下，随机实数是很难随机到某个具体的数的。

    from random import *
    i = 0
    while True:
        x = uniform(0,2)
        if x == 0:
            print(i)
            break
        else:
            print(x)
            i += 1

从上一个例子我们看到，虽然我不确定随具体随机到某个实数的概率是不是永远也没有可能，但肯定很小很小。所以如果我们要解决某个问题，需要某个确定的概率的话还是用随机整数好一些。

更多内容请参见[官方文档](http://docs.python.org/3.4/library/random.html)。

### statistics模块

这个模块python3.4才加入进来。

上面的那个例子这里稍作修改，使之成为一个骰子模拟器。其中`i_list`这个列表收集多次实验中掷多少次骰子才遇到6的次数。

    from random import *
    i_list = []
    while len(i_list) < 100:
        i = 1
        while True:#一次实验
            x = randint(1,6)
            if x == 6:
                print('times:' , i)
                break
            else:
                print(x)
                i += 1
        i_list.append(i)
    
    print(i_list)
    from statistics import *
    print(mean(i_list))#平均值
    print(median(i_list))#中位数，去掉最高最低...

statistics模块中的**mean**函数接受一组数值列表，然后返回这组数值的平均值。而**median**函数返回的是统计学上所谓的中位数，你可以简单看作一组数字不断的去掉一个最高和最低，然后剩下来的一个或者两个（两个要取平均值）的数值的值。

更多内容请参见[官方文档](https://docs.python.org/3/library/statistics.html)。

## 序列

字符串，列表，元组（tuple，这里最好翻译成元组，因为里面的内容不一定是数值。）都是序列（sequence）的子类，所以序列的一些性质他们都具有，最好在这里一起讲方便理解记忆。

### len函数

len函数返回序列所含元素的个数：

    string001='string'
    list001=['a','b','c']
    tuple001=(1,2,3,4)
    
    for x in [string001,list001,tuple001]:
        print(len(x))
    
    6
    3
    4
    >>> 

### 调出某个值

对于序列来说后面跟个方括号，然后加上序号（程序界的老规矩，从0开始计数。），那么调出对应位置的那个值。还以上面那个例子来说明。

    string001='string'
    list001=['a','b','c']
    tuple001=(1,2,3,4)
    
    for x in [string001,list001,tuple001]:
        print(x[2])
    
    r
    c
    3
    >>> 

#### 倒着来

倒着来计数-1表示倒数第一个，-2表示倒数第二个。依次类推。

    string001='string'
    list001=['a','b','c']
    tuple001=(1,2,3,4)
    
    for x in [string001,list001,tuple001]:
        print(x[-1],x[-2])
    
    g n
    c b
    4 3

### 调出多个值

前面不写表示从头开始，后面不写表示到达尾部。中间加个冒号的形式表示从那里到那里。这里**注意**后面那个元素是进来，看来python区间的默认含义都是包头不包尾。这样如果你想要最后一个元素也进去，只有使用默认的不写形式了。

    string001='string'
    list001=['a','b','c']
    tuple001=(1,2,3,4)
    
    for x in [string001,list001,tuple001]:
        print(x[1:3],x[-2:-1],x[:-1],x[1:],x[1:-1])
    
    tr n strin tring trin
    ['b', 'c'] ['b'] ['a', 'b'] ['b', 'c'] ['b']
    (2, 3) (3,) (1, 2, 3) (2, 3, 4) (2, 3)

用数学半开半闭区间的定义来理解这里的包含关系还是很便捷的。

1.  首先是数学半开半闭区间，左元素和右元素都是之前叙述的对应的定位点。左元素包含右元素不包含。

2.  其次方向应该是从左到右，如果定义的区间是从右到左，那么将产生空值。

3.  如果区间超过，那么从左到右包含的所有元素就是结果，。

4.  最后如果左右元素定位点相同，那么将产生空值，比如：\
    `string001[2:-4]`，其中2和-4实际上是定位在同一个元素之上的。额外值得一提的列表插入操作，请参看列表的插入操作这一小节。

### 序列反转

这是python最令人叹为观止的地方了，其他的语言可能对列表啊什么的反转要编写一个复杂的函数，我们python有一种令人感动的方法。

    string001='string'
    list001=['a','b','c']
    tuple001=(1,2,3,4)
    
    for x in [string001,list001,tuple001]:
        print(x[::-1])
    
    gnirts
    ['c', 'b', 'a']
    (4, 3, 2, 1)

之前在range函数的介绍时提及序列的索引和range函数的参数设置很是类似，这是我们可以参考理解之，序列（列表，字符串等）的索引参数 `[start:end:step]` 和range函数的参数设置一样，第一个参数是起步值，第二个参数是结束值，第三个参数是步长。这里end不填都好理解，就是迭代完即可，不过如果step是负数，似乎起点不填默认的是-1。

然后range函数生成的迭代器对象同样接受这种索引参数语法，看上去更加的怪异了：

    >>> range(1,10,2)
    range(1, 10, 2)
    >>> range(1,10,2)[::-2]
    range(9, -1, -4)
    
    >>> list(range(1,10,2))
    [1, 3, 5, 7, 9]
    >>> list(range(1,10,2)[::-2])
    [9, 5, 1]

我们可以看到对range函数进行切片操作之后返回的仍然是一个range对象，经过了一些修正。似乎这种切片操作和类的某个特殊方法有关，和python的slice对象有关。

### 序列的可更改性

字符串不可以直接更改，但可以组合成为新的字符串；列表可以直接更改；元组不可以直接更改。

### 序列的加法和减法

两个字符串相加就是字符串拼接了。乘法就是加法的重复，所以一个字符串乘以一个数字就是自己和自己拼接了几次。列表还有元组和字符串一样大致情况类似。

    print('abc'+'def')
    print('abc'*3)
    print([1,2,3]+[4,5,6])
    print((0,'a')*2)
    
    abcdef
    abcabcabc
    [1, 2, 3, 4, 5, 6]
    (0, 'a', 0, 'a')

## 字符串

python语言不像c语言，字符和字符串是不分的，用单引号或者双引号包起来就表示一个字符串了。单引号和双引号并没有什么特别的区别，只是如果字符串里面有单引号，那么就使用双引号，这样单引号直接作为字符处理而不需要而外的转义处理------所谓转义处理和其他很多编程语言一样用\\符号。比如要显示`'`就输入`\'`。

### 三单引号和三双引号

在单引号或者双引号的情况下，你可以使用`\n`来换行，其中\\n表示换行。此外还可以使用三单引号"'或者三双引号\"\"\"来包围横跨多行的字符串，其中换行的意义就是换行，不需要似前面那样的处理。

    print('''\
    这是一段测试文字
      this is a test line
          其中空白和    换行都所见所得式的保留。''')

### startswith方法

    >>> x = 'helloABC'
    >>> x
    'helloABC'
    >>> x.startswith('hello')
    True
    >>> x.endswith('ABC')
    True

startswith

:   测试字符串是否以某个子字符串开始

endswith

:   测试某个字符串是否以某个子字符串结束

### find方法

字符串的find方法可用来查找某个子字符串，没有找到返回-1，找到了返回字符串的偏移量。用法就是：`s.find('d')`。

### replace方法

字符串的replace方法进行替换操作，接受两个参数：第一个参数是待匹配的子字符串，第二个参数是要替换成为的样子。

    >>> print('a b 11 de'.replace('de','ding'))
    a b 11 ding
    >>> print('1,1,5,4,1,6'.replace('1','replaced'))
    replaced,replaced,5,4,replaced,6

### upper方法

将字符串转换成大写形式。

    >>> str='str'
    >>> str.upper()
    'STR'

类似的还有：

lower

:   都变成小写

capitalize

:   首字母大写，其它都小写。

### isdigit方法

isdigit

:   测试是不是数字

isalpha

:   测试是不是字母

isalnum

:   测试是不是数字或字母

。

### split方法

字符串的split方法可以将字符串比如有空格或者逗号等分隔符分割而成，可以将其分割成子字符串列表。默认是空格是分隔符。

    >>> string='a=1,b=2,c=3'
    >>> string.split(',')
    ['a=1', 'b=2', 'c=3']

#### splitline方法

把一个字符串按照行分开。这个可以用上面的split方法然后接受`\n`参数来实现，所不同的是splitline方法不需要接受参数：

    >>> string
    'this is line one\nthis is line two\nthis is line three'
    >>> string.splitlines()
    ['this is line one', 'this is line two', 'this is line three']
    >>> string.split('\n')
    ['this is line one', 'this is line two', 'this is line three']

### join方法

字符串的join方法非常有用，严格来说它接受一个迭代器参数，不过最常见的是列表。将列表中的多个字符串连接起来，我们看到他采用了一种非常优雅的方式，就是只有两个字符串之间才插入某个字符，这正是我们所需要的。具体例子如下所示：

    >>> list001=['a','b','c']
    >>> "".join(list001)
    'abc'
    >>> ','.join(list001)
    'a,b,c'

### strip方法

#### rstrip方法

字符串右边的空格都删除。换行符也会被删除掉。

#### lstrip方法

类似rstrip方法，字符串左边的空格都删除。换行符也会被删除掉。

### format方法

字符串的format方法方便对字符串内的一些变量进行替换操作，其中花括号不带数字跟format方法里面所有的替换量，带数字0表示第一个替换量，后面类推。此外还可以直接用确定的名字引用。

    >>> print('1+1={0}，2+2={1}'.format(1+1,2+2))
    1+1=2，2+2=4
    >>> print('my name is {name}'.format(name='Jim T Kirk'))
    my name is Jim T Kirk

### 转义和不转义

`\n    \t  `这是一般常用的转义字符，换行和制表。此外还有`\\`输出\\符号。

如果输出字符串不想转义那么使用如下格式：

    >>> print(r'\t \n \test')
    \t \n \test

### count方法

统计字符串中某个字符或某一连续的子字符串出现的次数。

    >>> string = 'this is a test line.'
    >>> string.count('this')
    1
    >>> string.count('t')
    3

### r什么的方法

rfind rindex rjust rsplit
，这些方法有时会很有用，而具体其含义的理解就对应于： find index ljust
split。

我想大家应该看一下就知道了，区别就是从右往左了。

## 列表

方括号包含几个元素就是列表。

### 列表的插入操作 

字符串和数组都不可以直接更改所以不存在这个问题，列表可以。其中列表还可以以一种定位在相同元素的区间的方法来实现插入操作，这个和之前理解的区间多少有点违和，不过考虑到定位在相同元素的区间本来就概念模糊，所以在这里就看作特例，视作在这个插入吧。

    list001=['one','two','three']
    list001[1:-2]=['four','five']
    print(list001)
    
    ['one', 'four', 'five', 'two', 'three']

extend方法似乎和列表之间的加法重合了，比如list.extend(\[4,5,6\])就和list=list+\[4,5,6\]是一致的，而且用加法表示还可以自由选择是不是覆盖原定义，这实际上更加自由。

insert方法也就是列表的插入操作：

    >>> list = [1,2,3,4]
    >>> list.insert(0,5)
    >>> list
    [5, 1, 2, 3, 4]
    >>> list.insert(2,'a')
    >>> list
    [5, 1, 'a', 2, 3, 4]

### append方法

python的append方法就是在最后面加**一个元素**，如果你append一个列表那么这一个列表整体作为一个元素。然后append方法会永久的改变了该列表对象的值。

记住，append等等原处修改列表的方法都是没有返回值的。

​    >>> list = [1,2,3,4]
​    >>> list.append(5)
​    >>> list
​    [1, 2, 3, 4, 5]

如果你希望不改动原列表的附加，请使用加法来操作列表。

### reverse方法

reverse方法不接受任何参数，直接将一个列表翻转过来。如果你希望不改变原列表的翻转，有返回值，请使用如下方法：

    >>> list
    [1, 2, 3, 4, 5]
    >>> listNew = list[::-1]
    >>> list
    [1, 2, 3, 4, 5]
    >>> listNew
    [5, 4, 3, 2, 1]

### copy方法

copy方法复制返回本列表。

#### sort方法

也就是排序，改变列表。默认是递增排序，可以用**reverse=True**来调成递减排序。

默认的递增排序顺序如果是数字那么意思是数字越来越大，如果是字符那么（似乎）是按照ACSII码编号递增来排序的。如果列表一些是数字一些是字符会报错。

    >>> list = ['a','ab','A','123','124','5']
    >>> list.sort()
    >>> list
    ['123', '124', '5', 'A', 'a', 'ab']

sort方法很重要的一个可选参数**key=function**，这个function函数就是你定义的函数（或者在这里直接使用lambda语句。），这个函数只接受一个参数，就是排序方法（在迭代列表时）接受的当前的那个元素。下面给出一段代码，其中tostr函数将接受的对象返回为字符，这样就不会出错了。

    def tostr(item):
        return str(item)
    
    list001 = ['a','ab','A',123,124,5]
    
    list001.sort(key=tostr)
    
    print(list001)
    
    [123, 124, 5, 'A', 'a', 'ab']

### sorted函数

sorted函数在这里和列表的sort方法最大的区别是它返回的是而不是原处修改。其次sorted函数的第一个参数严格来说是所谓的可迭代对象，也就是说它还可以接受除了列表之外的比如等可迭代对象。至于用法他们两个差别不大。

    >>> sorted((1,156,7,5))
    [1, 5, 7, 156]
    >>> sorted({'andy':5,'Andy':1,'black':9,'Black':55},key=str.lower)
    ['Andy', 'andy', 'black', 'Black']

上面第二个例子调用了**str.lower**函数，从而将接受的item，这里比如说'Andy'，转化为andy，然后参与排序。也就成了对英文字母大小写不敏感的排序方式了。

#### 字典按值排序

同样类似的有字典按值排序的方法[^4]：

    >>> sorted({'andy':5,'Andy':1,'black':9,'Black':55}.items(),key=lambda i: i[1])
    [('Andy', 1), ('andy', 5), ('black', 9), ('Black', 55)]

这个例子先用字典的items方法处理返回(key,value)对的可迭代对象，然后用后面的lambda方法返回具体接受item的值，从而根据值来排序。

#### 中文排序

下面这个例子演示了如何对中文名字排序。整个函数的思路就是用[pypinyin](https://github.com/mozillazg/python-pinyin)（一个第三方模块），将中文姓名的拼音对应出来，然后组成一个列表，然后根据拼音对这个组合列表排序，然后生成目标列表。

    list001=['张三','李四','王二','麻子','李二','李一']
    def zhsort(lst):
        from pypinyin import  lazy_pinyin
        pinyin=[lazy_pinyin(lst[i]) for i in range(len(lst))]
        lst0=[(a,b) for (a,b) in zip(lst,pinyin)]
        lst1= sorted(lst0, key=lambda d:d[1])
        return [x[0] for x in lst1]
    print(zhsort(list001))
    
    ['李二', '李四', '李一', '麻子', '王二', '张三']

### reversed函数

前面提到过序列反转可以这样做:

    lst[::-1]

不过更加推荐的做法是直接用reversed函数来做，reversed函数返回的是个可迭代对象。

    string001='string'
    list001=['a','b','c']
    tuple001=(1,2,3,4)
    
    for x in [string001,list001,tuple001]:
        print(list(reversed(x)))
    
    ['g', 'n', 'i', 'r', 't', 's']
    ['c', 'b', 'a']
    [4, 3, 2, 1]

然后我们马上就想到，列表有 `reverse`
方法，其是破坏型的方法，然后类似的还有 `sort`
方法，破坏型的，其对应非破坏型方法有 `sorted`
。一般使用没有特别需求时都应该使用非破坏型方法，reversed，sorted等等。

### 删除某个元素

-   赋空列表值，相当于所有元素都删除了。

-   pop方法：接受一个参数，就是列表元素的定位值，然后那个元素就删除了，方法并返回那个元素的值。如果不接受参数默认是删除最后一个元素。

-   remove方法：移除第一个相同的元素，如果没有返回相同的元素，返回错误。

-   del函数：删除列表中的某个元素。

<!-- -->

    >>> list001=['a','b','c','d','e']
    >>> list001.pop(2)
    'c'
    >>> list001
    ['a', 'b', 'd', 'e']
    >>> list001.pop()
    'e'
    >>> list001
    ['a', 'b', 'd']
    >>> list001.remove('a')
    >>> list001
    ['b', 'd']
    >>> del list001[1]
    >>> list001
    ['b']

### count方法

统计某个元素出现的次数。

    >>> list001=[1,'a',100,1,1,1]
    >>> list001.count(1)
    4

### index方法

index方法返回某个相同元素的偏移值。

    >>> list001=[1,'a',100]
    >>> list001.index('a')
    1

### 列表解析

我们来看下面这个例子：

    def square(n):
        return n*n
        
    print(list(map(square,[1,2,3,4,5])))
    print([square(x) for x in [1,2,3,4,5]])
    
    [1, 4, 9, 16, 25]
    [1, 4, 9, 16, 25]

map函数将某个函数应用于某个列表的元素中并生成一个map对象（可迭代对象），需要外面加上list函数才能生成列表形式。第二种方式更有python风格，是推荐使用的列表解析方法。

在python中推荐多使用迭代操作和如上的列表解析风格，因为python中的迭代操作是直接用c语言实现的。

#### 列表解析加上过滤条件

for语句后面可以跟一个if子句表示过滤条件，看下面的例子来理解吧：

    >>> [s*2 for s in ['hello','abc','final','help'] if s[0] == 'h']
    ['hellohello', 'helphelp']

这个例子的意思是列表解析，找到的元素进行乘以2的操作，其中过滤条件为字符是h字母开头的，也就是后面if表达式不为真的元素都被过滤掉了。

#### 完整的列表解析结构

下面给出一个完整的列表解析结构，最常见的情况一般就一两个for语句吧，这里if外加个括号是可选项的意思。

    [ expression for var1 in iterable1 [if condition1 ]
                        for var2 in iterable2 [if condition2 ]
                        ........
                                ]

这里的逻辑是从左到右第一个for语句就是最先执行的for语句，然后是第二个for语句跟着执行。

这里的iterable1是指某个可迭代对象，也就是说那些能够返回可迭代对象的函数比如map，filter，zip，range等函数都可以放进去。不过我们要克制自己在这里别写出太过于晦涩的程序了。还有for循环语句也别嵌套太多了，这样就极容易出错的。

下面这个程序大家看看：

    >>> [x+str(y) for x in ['a','b','c'] for y in [1,2,3,4,5,6] if y & 1]
    ['a1', 'a3', 'a5', 'b1', 'b3', 'b5', 'c1', 'c3', 'c5']
    >>> [x+str(y) for x in ['a','b','c'] for y in [1,2,3,4,5,6] if not  y & 1]
    ['a2', 'a4', 'a6', 'b2', 'b4', 'b6', 'c2', 'c4', 'c6']

**Notice:** 推荐不要写带两个for语句以上的列表解析，参看[高质量python代码] 。

#### 列表解析的好处

在熟悉列表解析的语句结构之后，一两个for语句不太复杂的情况下，还是很简单明了的。同时语法也更加精炼，同时运行速度较for循环要至少快上一倍。最后python的迭代思想深入骨髓，以后python的优化工作很多都围绕迭代展开，也就是多用列表解析会让你的代码以后可能运行的更快。

有这么多的好处，加上这么cool的pythonic风格，推荐大家多用列表解析风格解决问题。

#### 元组的生成

这个时候需要明确加个括号表示这是一个元组对象。

    >>> [(x,x**2) for x in range(5)]
    [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16)]

### for语句中列表可变的影响

一般情况for迭代某个可迭代对象就是可迭代对象返回一个值然后利用这个值赋值并进行下面的操作，但是列表却是一个可变的东西，如果列表在操作中被修改了，情况会怎样呢？

    lst = [1,2,3,4,5]
    index = 0
    for x in lst:
        lst.pop(index)
        print(x)
    
    1
    3
    5

具体这个过程的细节我不清楚，但确定的是在这里for语句并没有记忆原列表，而只是记忆了返回次数或者偏移值。

### 列表元素替换

推荐用列表解析方法来实现列表元素的替换功能。

    def replace(x,a,b):
        if x == a:
            return b
        else:
            return x
    
    lst=[1,5,4,1,6]
    
    >>> [replace(i,1,'replaced') for i in lst]
    ['replaced', 5, 4, 'replaced', 6]

### 列表元素去重

列表元素去重推荐用后来的set集合对象来处理之，其会自动去除重复的元素。

    >>> lst = [1,2,3,4,5,1,2,3,4,5]
    >>> [i for i in set(lst)]
    [1, 2, 3, 4, 5]

## 元组

圆括号包含几个元素就是元组(tuple)。元组和列表的不同在于元组是不可改变。元组也是从属于序列对象的，元组的很多方法之前都讲了。而且元组在使用上和列表极其接近，有很多内容这里也略过了。

值得一提的是如果输入的时候写的是*x,y*这样的形式，实际上表达式就加上括号了，也就是一个元组了*(x,y)*。

### 生成器表达式

类似列表解析，如果元组在这里解析也是返回的元组吗？这里并不是如此，前面谈到python中一般表达式的圆括号是忽略了的，所以这里的元组解析表示式有个更专门的名字叫做生成器表达式，它返回的是生成器对象，和生成器函数具体调用之后返回的对象是一样的。生成器对象具有`__next__`方法，可以调用next函数。

    >>> x = [i for i in [1,2,3]]
    >>> x
    [1, 2, 3]
    >>> y = (i for i in [1,2,3])
    >>> y
    <generator object <genexpr> at 0xb70dbe8c>

## 字典

与列表一样字典是可变的，可以像列表一样引用然后原处修改，del语句也适用。

并非所有对象都可以做字典key，在python中所有的内置不可变对象都是可散列的，所有的可变对象都是不可散列的。而只有可散列的才可以做字典的key。可散列的对象具有：

- 具有 `__hash__` 方法，这样可以比较大小
- 具有 `__eq__` 方法，这样可以判断相等。

所有值得一提的就是元组是可以做字典的key的。这里顺便提一下元组是如何比较大小的，在python中元组比较大小是：

### 元组和列表的比较大小

元组和列表的相等判断还是很好理解的，而对于这样的东西:

    >>> (1,-1) < (2,-2)

确实就有点古怪了。请读者参考[这个网页](http://stackoverflow.com/questions/5292303/python-tuple-comparison))，按照官方文档的说明：

> Tuples and lists are compared lexicographically using comparison of
> corresponding elements. This means that to compare equal, each element
> must compare equal and the two sequences must be of the same type and
> have the same length.

官方文档对于大于小于的情况并没有说得很清楚，然后我们从字里行间大体领会的精神是:

1.  可迭代对象比较大小，是逐个比较的。

2.  可迭代对象比较和相等测试最后一定返回True或False。

3.  逐个比较首先比较是不是相等，如果相等则跳过这个元素的比较，直到遇到某两个不相等的元素，然后返回的就是这两个元素的比较结果。

4.  最后快比较完了（以最小的可迭代对象长度为准），然后如果是相等判断操作，则长度相等就认为两者相等了；而如果是大小判断操作，则认为长度更长的那个对象更大。

下面是一些例子:

    >>> (1,-1) < (2,-2)
    True
    >>> (1,-1) < (-1,-2)
    False
    >>> (1,-1,-3) < (1,-1)
    False
    >>> (1,-1,) < (1,-1,0)
    True
### 创建字典

字典是一种映射，并没有从左到右的顺序，只是简单地将键映射到值。字典的声明格式如下：

    dict001={'name':'tom','height':'180','color':'red'}
    dict001['name']

或者创建一个空字典，然后一边赋值一边创建对应的键：

    dict002={}
    dict002['name']='bob'
    dict002['height']=195

#### 根据列表创建字典

如果是\[\['a',1\],\['b',2\],\['c',3\]\]这样的形式，那么直接用dict函数处理就变成字典了，如果是\['a','b','c'\]和\[1,2,3\]这样的形式那么需要用zip函数处理一下，然后用dict函数处理一次就变成字典了：

    >>> lst
    [['a', 1], ['b', 2], ['c', 3]]
    >>> dict001=dict(lst)
    >>> dict001
    {'a': 1, 'b': 2, 'c': 3}



### 字典里面有字典

和列表的不同就在于字典的索引方式是根据"键"来的。

    dict003={'name':{'first':'bob','second':'smith'}}
    dict003['name']['first']

### 字典遍历操作

字典特定顺序的遍历操作的通用做法就是通过字典的keys方法收集键的列表，然后用列表的sort方法处理之后用for语句遍历，如下所示：

    dict={'a':1,'c':2,'b':3}
    dictkeys=list(dict.keys())
    dictkeys.sort()
    for key in dictkeys:
        print(key,'->',dict[key])

*警告*：上面的例子可能对python早期版本并不使用，保险起见，推荐使用sorted函数，sorted函数是默认对字典的键进行排序并返回键的值组成的列表。

    dict={'a':1,'c':3,'b':2}
    >>> for key in sorted(dict):
    ...   print(key,'->',dict[key])
    ... 
    a -> 1
    b -> 2
    c -> 3

如果你对字典遍历的顺序没有要求，那么就可以简单的这样处理：

    >>> for key in dict:
    ...     print(key,'->',dict[key])
    ... 
    c -> 2
    a -> 1
    b -> 3

#### keys方法

收集键值，返回。

#### values方法

和keys方法类似，收集的值，返回。

    >>> dict001.values()
    dict_values([3, 1, 2])
    >>> list(dict001.values())
    [3, 1, 2]

#### items方法

和keys和values方法类似，不同的是返回的是(key,value)对的。

    >>> dict001.items()
    dict_items([('c', 3), ('a', 1), ('b', 2)])
    >>> list(dict001.items())
    [('c', 3), ('a', 1), ('b', 2)]

嗯，python2上面的三个方法是直接返回的列表，python3返回可迭代对象更节省计算资源些。

### 字典的in语句

可以看到in语句只针对字典的键，不针对字典的值。

    >>> dict001={'a':1,'b':2,'c':3}
    >>> 2 in dict001
    False
    >>> 'b' in dict001
    True

### 字典对象的get方法

get方法是去找某个键的值，为什么不直接引用呢，get方法的好处就是某个键不存在也不会出错。

    >>> dict001={'a':1,'b':2,'c':3}
    >>> dict001.get('b')
    2
    >>> dict001.get('e')

### update方法

感觉字典就是一个小型数据库，update方法将另外一个字典里面的键和值覆盖进之前的字典中去，称之为更新，没有的加上，有的覆盖。

    >>> dict001={'a':1,'b':2,'c':3}
    >>> dict002={'e':4,'a':5}
    >>> dict001.update(dict002)
    >>> dict001
    {'c': 3, 'a': 5, 'e': 4, 'b': 2}

### pop方法

pop方法类似列表的pop方法，不同引用的是键，而不是偏移地址，这个就不多说了。

### 字典解析 

这种字典解析方式还是很好理解的。

    >>> dict001={x:x**2 for x in [1,2,3,4]}
    >>> dict001
    {1: 1, 2: 4, 3: 9, 4: 16}

#### zip函数创建字典

可以利用zip函数来通过两个可迭代对象平行合成一个配对元素的可迭代对象，然后用dict函数将其变成字典对象。

    >>> dict001=zip(['a','b','c'],[1,2,3])
    >>> dict001
    <zip object at 0xb7055eac>
    >>> dict001=dict(dict001)
    >>> dict001
    {'c': 3, 'b': 2, 'a': 1}

## 集合

python实现了数学上的无序不重复元素的集合概念，在前面讨论列表去重元素的时候我们提到过正好可以利用集合的这一特性。

    >>> list001=[1,2,3,1,2,4,4,5,5,5,7]
    >>> {x for x in list001}
    {1, 2, 3, 4, 5, 7}
    >>> set(list001)
    {1, 2, 3, 4, 5, 7}

用集合解析的形式表示出来就是强调set命令可以将任何可迭代对象都变成集合类型。当然如果我们希望继续使用列表的话使用list命令强制类型转换为列表类型即可，不过如果我们在应用中确实一致需要元素不重复这一特性，就可以考虑直接使用集合作为主数据操作类型。

集合也是可迭代对象。关于可迭代对象可以进行的列表解析操作等等就不啰嗦了。下面介绍集合的一些操作。

### 集合添加元素

值得一提的是如果想创建一个空的集合,
需要用set命令，用花括号系统会认为你创建的是空字典。然后我们看到用集合的**add**方法添加，那些重复的元素是添加不进来的。

*警告*：值得一提的是集合只能包括不可变类型，因此列表和字典不能作为集合内部的元素。元组不可变，所以可以加进去。

    >>> set001=set()
    >>> set001.add(1)
    >>> set001
    {1}
    >>> set001.add(2)
    >>> set001
    {1, 2}
    >>> set001.add(1)
    >>> set001
    {1, 2}

或者使用update方法一次更新多个元素：

    >>> set001=set('a')
    >>> set001.update('a','b','c')
    >>> set001
    {'b', 'a', 'c'}

### 集合去掉某个元素

有两个集合对象的方法可以用于去掉集合中的某个元素，discard方法和remove方法，其中discard方法如果删除集合中没有的元素那么什么都不会发生，而remove方法如果删除某个不存在的元素那么会产生KeyError。

    >>> set001=set('hello')
    >>> set001.discard('h')
    >>> set001
    {'e', 'o', 'l'}
    >>> set001.discard('l')
    >>> set001
    {'e', 'o'}

remove方法与之类似就不做演示了。

### 两个集合之间的关系

#### 子集判断

集合对象有一个issubset方法用于判断这个集合是不是那个集合的子集。

    >>> set001=set(['a','b'])
    >>> set002=set(['a','b','c'])
    >>> set001.issubset(set002)
    True

还有更加简便的方式比较两个集合之间的关系，那就是\>，\<，\>=，\<=，==这样的判断都是适用的。也就是set001是set002的子集，它的元素set002都包含，那么set001\<=set002，然后真子集的概念就是set001\<set002即不等于即可。

### 两个集合之间的操作

下面的例子演示的是两个集合之间的交集：*&*，并集：*\|*，差集：*-*。

    >>> set001=set('hello')
    >>> set002=set('hao')
    >>> set001 & set002 #交集
    {'o', 'h'}
    >>> set001 | set002 #并集
    {'h', 'l', 'a', 'e', 'o'}
    >>> set001 - set002 #差集
    {'e', 'l'}

类似的集合对象还有intersection方法，union方法，difference方法：

    >>> set001=set('hello')
    >>> set002=set('hao')
    >>> set001.intersection(set002) #交集
    {'h', 'o'}
    >>> set001.union(set002) #并集
    {'e', 'a', 'h', 'o', 'l'}
    >>> set001.difference(set002) #差集
    {'e', 'l'}

### clear方法

将一个集合清空。

### copy方法

类似列表的copy方法，制作一个集合copy备份然后赋值给其他变量。

### pop方法

无序弹出集合中的一个元素，直到没有然后返回KeyError错误。

## bytes类型

### 基本编码知识

具体存储在计算机里面的都是二进制流，而如果要将其正确解析成为对应的字符，是需要建立一定的编码规则的。比如大家熟悉的ASCⅡ编码规则。ACSⅡ编码是Latin-1和utf-8等编码的子集，也就是一连串基于ACSⅡ编码的字符串用utf-8编码也能正确解析。

python2中目前也支持 **bytes** 类型了 [^5] 。然后python2还有一个
**unicode** 类型。

bytes简单的理解就是没有任何字符含义的二进制字节流。然后如这样 `b'test'`
，在前面加个字符b或者B，其将解析为bytes类型。

    >>> x = b'test'
    >>> x
    b'test'
    >>> type(x)
    <class 'bytes'>
    >>> x[0]
    116
    >>> x[1]
    101
    >>> list(x)
    [116, 101, 115, 116]
    >>> 

python在打印时会尽可能打印可见字符，尽管上面的x打印显示出了具体的test这个字符，但我们应该认为x是一连串的数字序列而不具有任何字符串含义，如果我们调用bytes类型的**decode**方法，那么bytes类型解码之后将变成str类型。

    >>> y = x.decode('utf-8')
    >>> y
    'test'
    >>> type(y)
    <class 'str'>

当然具体编码方式是否正确，是否正确解析了原bytes字节流那又是另外一回事了。比如还可能是big5或者GB什么的编码。

此外字符串str类型有个**encode**方法可以进行编码操作从而输出对应编码的bytes字节流。

### 使用方法

我们可以如下看一下str类型和bytes类型具体有那些方法差异:

    >>> set(dir('abc')) - set(dir(b'abc'))
    {'isdecimal', 'casefold', '__rmod__', 'format_map', 'format', 'encode', '__mod__', 'isnumeric', 'isprintable', 'isidentifier'}
    >>> set(dir(b'abc')) - set(dir('abc'))
    {'decode', 'fromhex'}

我们看到bytes和str几乎拥有相同的功能，所以大部分之前学到的用于str字符串类型的那些方法同样可以用于bytes类型中。这多少有点方法泛滥了，因为bytes是字节流类型，内在是没有字符含义的，可能某些方法并不推荐使用。

比如下面的upper方法和replace方法:

    >>> b't'.upper()
    b'T'
    >>> b'testst'.replace(b'st',b'oo')
    b'teoooo'

然后字节流的连接可以很方便的用加法或join方法来进行，如下所示:

    >>> b't' + b'e'
    b'te'
    >>> b''.join([b'a',b'c'])
    b'ac'

但是要*注意*，python2里面不管是加法还是join方法都将丢掉那个b修饰符[^6]:

    >>> b''.join([b'a',b'c'])
    'ac'
    >>> b'a' + b'b'
    'ab'

不过这也无关紧要，因为python2里面我们可以理解str就对应的是python3的bytes类型，然后unicode对应的就是python3的str类型。

## bytearray类型

bytearray和bytes类型类似，而且其内部支持的方法和操作也和bytes类型类似，除了其更像是一个列表，可以原处修改而字符串和bytes是不可变的。python2现在也有bytearray类型了，只是内在的文本和二进制是不分的。

## 文件

文件对象是可迭代对象。

### 写文件

对文件的操作首先需要用**open**函数创建一个文件对象，简单的理解就是把相应的接口搭接好。文件对象的**write**方法进行对某个文件的写操作，最后需要调用**close**方法写的内容才真的写进去了。

    file001 = open('test.txt','w')
    file001.write('hello world1\n')
    file001.write('hello world2\n')
    file001.close()

如果你们了解C语言的文件操作，在这里会为python语言的简单便捷赞叹不已。就是这样三句话：创建一个文件对象，然后调用这个文件对象的wirte方法写入一些内容，然后用close方法关闭这个文件即可。

### 读文件

一般的用法就是用**open**函数创建一个文件对象，然后用**read**方法调用文件的内容。最后记得用**close**关闭文件。

    file001 = open('test.txt')
    filetext=file001.read()
    print(filetext)
    file001.close()

此外还有**readline**方法是一行一行的读取某文件的内容。

### open函数的处理模式

open函数的处理模式如下：

'r'

:   默认值，read，读文件。

'w'

:   wirte，写文件，如果文件不存在会创建文件，如果文件已存在，文件原内容会清空。

'a'

:   append，附加内容，也就是后面用write方法内容会附加在原文件之后。

'b'

:   处理模式设置的选项，'b'不能单独存在，要和上面三个基本模式进行组合，比如'rb'等，意思是二进制数据格式读。

'+'

:   处理模式设置的选项，同样'+'不能单独存在，要和上面三个基本模式进行组合，比如'r+'等，+是updating更新的意思，也就是既可以读也可以写，那么'r+'，'w+'，'a+'还有什么区别呢？区别就是'r+'不具有文件创建功能，如果文件不存在会报错，然后'r+'不会清空文件，如果'r+'不清空文件用write方法情况会有点复杂；而'w+'具有文件创建功能，然后'w+'的write方法内容都是重新开始的；而'a+'的write方法内容是附加在原文件上的，然后'a+'也有文件创建功能。

### 用with语句打开文件

类似之前的例子我们可以用with语句来打开文件，这样就不用close方法来关闭文件了。然后with语句来提供了类似try语句的功能可以自动应对打开文件时的一些异常情况。

    with open('test.txt','w') as file01:
        file01.write('hello world1\n')
        file01.write('hello world2\n')
    
    with open('test.txt','r') as file01:
        filetext=file01.read()
        print(filetext)


[^2]: is语句用来测试对象的同一性，就是真正是内存里的同一个东西，而不仅仅是值相同而已。==只是确保值相同。
[^3]: 这些int、float等命令都是强制类型转换命令
[^4]: [参考网站](http://www.cnpythoner.com/post/266.html)