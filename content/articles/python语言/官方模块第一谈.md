Title: python语言学习之-官方模块第一谈
Slug: python-modules
Date: 2017-05-05
Modified: 2018-10-04

[TOC]







unittest模块
------------

在编程中有一个概念TDD，其和具体的编程语言无关，其全称叫做test-driven
development。也就是人们常说的测试驱动型开发。不说这么大的概念，但在python编程开发中有一块内容是你必须要了解的，那就是单元测试开发。具体python中内置模块unittest就是做这个工作的。

基本的使用就简单用下面这个例子来说明了：

    import unittest
    import math
    
    class TooBigError(Exception):
        pass
    
    def hello(n):
        if n>2:
            raise TooBigError('too big input error')
        else:
            print('hello'*n)
    
    class FirstTest(unittest.TestCase):
        def setUp(self):
            '''setUp函数在每个测试单元执行前被执行，其通常用于预先配置
            一些后面测试单元会用到的参数'''
            pass
    
        def tearDown(self):
            '''tearDown函数在每个测试单元执行之后再执行。'''
            pass
    
        def test_bool(self):
            '''具体的测试单元，名字需要以test字符开始'''
            self.assertTrue(True)
            self.assertFalse(False)
        def test_equal(self):
            self.assertEqual(1,1)
            self.assertNotEqual(1,2)
            self.assertAlmostEqual(math.pi, 3.1416,4)
            self.assertNotAlmostEqual(math.pi, 3.1415,4)
    
        def test_raises(self):
            self.assertRaises(TooBigError, hello, 3)


    if __name__ == '__main__':
        unittest.main()

unittest模块的main函数具体实际执行各个测试单元类，这些测试单元类继承自unittest的TestCase类。在这些继承自TestCase的类中，setUp函数和tearDown函数有特殊的用途，具体见上面代码的说明。然后里面定义的函数test字符串开头的都是所谓的测试单元，其将被逐个执行。

TestCase有很多方法，比如assertTrue，assertFalse用于断言某个bool值是真或假，然后assertEqual用来断言某两个值是相等的(==)，类似的还有assertNotEqual用来断言两个值不相等。这里值得一提的assertAlmostEqual方法是用来断言某两个float值在多少小数位上是大致相等的，比如上面的例子，
$\pi$
值具体到小数点4位是3.1416。上面这些方法后面还可以额外接受一个提示字符串参数（Msg参数），用来具体没有断言成功的时的补充信息。

assertRaises方法用来断言某个函数在接受某些参数之后必然返回某个异常。该方法第一个参数是期望捕捉到的异常，第二个参数是具体调用的函数，后面的参数将送给这个函数，所以就不能跟之前谈及的Msg参数了。

更多信息请参看该模块的官方文档。

time模块
--------

time模块提供了一些和时间相关的函数，更加的底层，不过有些函数可能在某些平台并不适用。类似的模块还有datetime模块，datetime是以类的框架来解决一些时间问题的。所以如果只是需要简单的调用一下时间，那么用time模块，如果是大量和时间相关的问题，推荐使用datetime模块。

### time函数

    >>> import time
    >>> time.time()
    1404348227.07554

time函数返回一个数值，这个数值表示从1970年1月1号0时0分0秒到现在的时间过了多少秒。

### gmtime函数

这个函数可以接受一个参数，这个参数是多少秒，然后返回一个特定格式的时间数组`struct_time`。如果不接受参数，那么默认接受的秒数由time函数返回，也就是从那个特定时间到现在过了多少秒，这样这个特定格式的时间数组对应的就是当前时间。

    >>> time.gmtime()
    time.struct_time(tm_year=2014, tm_mon=7, tm_mday=3, tm_hour=0, 
    tm_min=53, tm_sec=0, tm_wday=3, tm_yday=184, tm_isdst=0)
    >>> time.gmtime(0)
    time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, 
    tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)

### localtime函数

此外类似的还有**localtime**函数，和gmtime用法和返回完全一模一样，唯一的区别就是返回的是当地的时间。

    >>> time.strftime('%Y-%m-%d %H:%M:%S',time.localtime())
    '2014-07-03 09:19:40'
    >>> time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime())
    '2014-07-03 01:19:49'

### ctime函数

    >>> time.ctime()
    'Thu Jul  3 08:54:54 2014'
    >>> time.ctime(0)
    'Thu Jan  1 07:00:00 1970'

和gmtime类似，不过返回的是字符串格式的时间。我们看到ctime默认设置的时间是根据localtime函数来的。

### strftime函数

接受那个特定格式的时间数组`struct_time`作为参数，然后返回一定字符串格式的时间。具体例子请参看前面的例子。

其中最常用的格式符有：

    %Y，多少年；%m，多少月；%d，多少日；
    %H，多少小时；%M，多少分；%S，多少秒。

\%X直接输出09:27:19这样的格式，也就是前面的多少小时多少分多少秒可以用一个%X表示即可。

还有一些，比如：%I表示多少小时，不过是\[0-12\]的形式；%y表示多少年，不过是\[00-99\]的格式，比如2014年就输出14；%p，本地的AM或PM文字。等等。

### sleep函数 

sleep函数有时需要用到，将程序休眠个几秒的意思。需要接受一个数值参数，单位是秒，可以是零点几秒。但sleep函数只是大概休眠几秒的意思，最好不去用来计时，因为它不大精确。

更多内容请参见[官方文档](https://docs.python.org/3/library/time.html)。

sys模块
-------

sys模块有一些功能很常用，其实在前面我们就看到过一些了。

### sys.argv

在刚开始说明python执行脚本参数传递的问题时就已经讲了sys.argv这个变量。这是一个由字符串组成的列表。

    import sys
    
    print(sys.argv)
    for i in range(len(sys.argv)):
        print(sys.argv[i])

比如新建上面的一个test.py文件，然后执行：

    python3 test.py test1 test2
    ['test.py', 'test1', 'test2']
    test.py
    test1
    test2

我们可以看到sys.argv\[0\]就是这个脚本的文件名，然后后面依次是各个参数。

### exit函数

这个我们在编写GUI程序的时候经常看到，在其他脚本程序中也很常用。如果不带参数的话那么直接退出程序，还可以带一个字符串参数，返回错误提示信息，或者带一个数字，这里的详细讨论略过。

    >>> import sys
    >>> sys.exit('出错了')
    出错了
    wanze@wanze-ubuntu:~$ 

### sys.platform

返回当前脚本执行的操作系统环境。

Linux 返回字符串值：linux；Windows返回win32；Mac OS X 返回darwin。

### sys.path

一连串字符串列表，是python脚本模块的搜索路径，所以我们自定义的python模块，只需要在sys.path这个列表上新加一个字符串路径即可。

### 标准输入输出错误输出文件

sys.stdin，sys.stdout，sys.stderr这三个文件对象对应的就是linux系统所谓的标准输入标准输出和错误输出文件流对象。

### sys.version

sys.version输出当前python的版本信息和编译环境的详细信息。

sys.version\_info\[0\]
返回当前python主版本的标识，比如python3就返回数字3。

### sys.maxsize

返回当前计算环境下整数(int)类型的最大值，32位系统是$2**31-1$。

    >>> 2**31-1
    2147483647
    >>> import sys
    >>> sys.maxsize
    2147483647

### sys.stdin.isatty()

测试输入流是不是终端。如果是终端，则返回True。

更多内容请参见[官方文档](https://docs.python.org/3/library/sys.html)。

subprocess模块
--------------

我想大家都注意到了现在的计算机都是多任务的，这种多任务的实现机制就是所谓的多个进程同时运行，因为计算机只有一个CPU（现在多核的越来越普及了。）所有计算机一次只能处理一个进程，而这种多进程的实现有点类似你人脑（当然不排除某些极个别现象），你不能一边看电影一边写作业，但是可以写一会作业然后再看一会电影（当然不推荐这么做、），计算机的多进程实现机制也和这个类似，就是一会干这个进程，一会儿做那个进程。

计算机的一个进程里面还可以分为很多个线程，这个较为复杂，就不谈了。比如你编写的一个脚本程序，系统就会给它分配一个进程号之类的，然后cpu有时就会转过头来执行它一下（计算机各个进程之间的切换很快的，所以才会给我们一种多任务的错觉。）而你的脚本程序里面还可以再开出其他的子进程出来，
python的subprocess模块主要负责这方面的工作。

### call函数

    import subprocess
    
    # Command with shell expansion
    subprocess.call(["echo", "hello world"])
    subprocess.call(["echo", "$HOME"])
    subprocess.call('echo $HOME',shell=True)
    
    hello world
    $HOME
    /home/wanze

其中使用shell=True选项后用法较简单较直观，但网上提及安全性和兼容性可能有问题，他们推荐一般不适用shell=True这个选项。

如果不使用shell=True这个选项的，比如这里`$HOME`这个系统变量就无法正确翻译过来，如果实在需要home路径，需要使用os.path的expanduser函数。

### getoutput函数

取出某个进程命令的输出，返回的是字符串形式。

    import subprocess
    
    name=subprocess.getoutput('whoami')
    print(name)

### getstatusoutput函数

某个进程执行的状态。

### Popen类

根据Popen类创建一个进程管理实例，可以进行进程的沟通，暂停，关闭等等操作。前面的函数的实现是基于Popen类的，这是较高级的课题，这里暂时略过。

更多内容请参见[官方文档](https://docs.python.org/3/library/subprocess.html)。

shutil模块
----------

相当于os模块的补充，shutil模块进一步提供了一些系统级别的文件或文件夹的复制，删除，移动等等操作。

### 复制文件

    shutil.copyfile(src, dst)
    shutil.copy(src, dst)
    shutil.copy2(src, dst)

其中**copyfile**的src和dst两个参量都是完整文件路径名，第一个参量是待复制的文件，第二个参量是复制后的文件名；而**copy**函数的第一个参量是待复制的文件，但是第二个参量是目标文件夹路径；**copy2**函数和copy函数类似，不同的是它能尝试保留文件的所有元信息metadata（模块开头有说明是理论上但不尽然）。

### 复制文件夹

    shutil.copytree(src, dst)

**copytree**函数第一个参量是待复制的文件夹路径名，第二个参量是目标文件夹路径名，其将被创建不应该存在。

### 删除整个目录

    shutil.rmtree(path)

**rmtree**函数用于删除整个文件夹，path就是目标文件夹的路径名。

### 移动文件夹

    shutil.move(src,dst)

**move**函数把一个文件或者一个文件夹移动到一个文件夹内。

### chown函数

    shutil.chown(path, user=None, group=None)

**chown**函数类似的linux系统下的chown函数，这个函数基于os.chown函数，不过接口更友好。

### which函数

    shutil.which(cmd)

**which**函数类似的linux系统下的which函数。

更多shutil模块内容请参见[官方文档](https://docs.python.org/3.4/library/shutil.html)。

os模块
------

### getcwd函数

不管你在终端运行python还是运行某个python脚本，总有一个变量存储着当前工作目录的位置。你可以通过getcwd命令来查看当前工作目录。

    import os
    print(os.getcwd())

上面是通过LaTeX文件运行的python小脚本，当你以python命令来运行某个脚本的时候，你调用python命令的地方就是当前的工作目录。然后加载的其他模块的各个py文件运行时的当前工作目录和主py文件脚本的当前目录是一样的，都是你运行python命令的地方。

如果是终端调用python就是你终端的当前工作目录所在，你可以用pwd命令来查看。如下所示：

    =>pwd
    /home/wanze
    =>python3
    >>> import os
    >>> print(os.getcwd())
    /home/wanze

### mkdir函数

新建一个文件夹。

    os.mkdir(str)

### chdir函数

os模块里有一个chdir函数来更改当前工作目录所在地。

可以使用*.*和*..*语法，也可以使用简单的\"test\"调转到test文件夹。

    >>> os.chdir('/home/wanze/pymf')
    >>> print(os.getcwd())
    /home/wanze/pymf

### 删除文件

os.remove(path)

支持相对路径表达。如果路径是目录将会抛出一个OSError异常。

### os.rename

    os.rename(src, dst)

第一个参数是目标文件或目录，第二个参数是要替换成为的名字。这个命令一方面可以重命名文件，此外可以移动文件。

支持相对路径语法表达，rename在windows下不一定替换原文件，repalce一定替换文件。

### os.repalce

    os.replace(src, dst)

rename在windows下不一定替换原文件，repalce一定替换文件。

支持相对路径语法表达。

### 删除空目录

os.rmdir(path)

支持相对路径语法表达，只能删除空目录。如果要删除整个目录，请使用shutil.rmtree(path)。

### listdir命令

    os.listdir(path='.')

相当于简单的ls命令，将返回一个字符串列表，其内包含本path下所有的文件和文件夹名（包括链接文件）。

可以结合前面介绍的os.path模块的isfile等函数新建一个函数listdir\_file，listdir\_dir和listdir\_link，将普通文件，目录和链接文件区分开来。

    import os
    
    def listdir_dir(path='.'):
        '''os的listdir函数加强，只返回文件夹。'''
        return [dir for dir in os.listdir(path) if os.path.isdir(dir) ]
    def listdir_file(path='.'):
        '''os的listdir函数加强，只返回普通文件'''
        return [file for file in os.listdir(path) if os.path.isfile(file)
         and  not os.path.islink(file)]
    def listdir_link(path='.'):
        '''os的listdir函数加强，只返回链接文件'''
        return [link for link in os.listdir(path) if os.path.islink(link) ]

### 遍历目录树

    os.walk('.')

产生一个生成器对象，具体数值含义如下：（dirpath, dirnames,
filenames），其中dirpath和filenames可以合并出本目录下所有文件的具体文件名路径，而dirpath和dirnames可以合并出本目录下所有目录的具体路径名。

根据这个os.walk函数我写了一个`gen_file`
函数，其是一个生成器函数，会遍历目录树，并返回本目录下的文件信息。具体代码如下所示:

    def gen_file(startpath='.',filetype=""):
        '''利用os.walk 遍历某个目录，收集其内的文件，返回
        (文件路径列表, 本路径下的文件列表)
        比如:
        (['shortly'], ['shortly.py'])
    (['shortly', 'templates'], ['shortly.py'])
    (['shortly', 'static'], ['shortly.py'])
    
        第一个可选参数 startpath  默认值 '.'
        第二个参数  filetype  正则表达式模板 默认值是"" 其作用是只选择某些文件
        如果是空值，则所有的文件都将被选中。比如 "html$|pdf$" 将只选中 html和pdf文件。
        '''
        for root, dirs, files in os.walk(startpath):
            filelist = []
            for f in files:
                fileName,fileExt = os.path.splitext(f)
                if filetype:
                    if re.search(filetype,fileExt):
                        filelist.append(f)
                else:
                    filelist = files
            if filelist:#空文件夹不加入
                dirlist = root.split(os.path.sep)
                dirlist = dirlist[1:]
                if dirlist:
                    yield (dirlist, filelist)
                else:
                    yield (['.'], filelist)

这个函数可以帮助你管理本目录下（可以通过正则表达式过滤）你感兴趣的文件，都刷一边。然后继续必要的操作，比如查找等等之类的。

### environ函数

os.environ，返回一个字典值，这个字典值里面存储着当前shell的一些变量和值。比如系统中"HOME"所具体的路径名是：

    import os
    print(os.environ['HOME'])
    
    /home/wanze
    >>> 

### getpid函数

os.getpid函数，返回当前运行的进程的pid。

### stat函数

返回文件的一些信息。比如st\_size是文件的大小，单位是字节。

#### st\_size属性

    import os
    import glob
    
    print([os.path.abspath(f) for f in glob.glob('*.py')])
    
    print([f for f in glob.glob('*.py') if os.stat(f).st_size > 400])
    
    ['/home/wanze/桌面/test.py', '/home/wanze/桌面/flatten.py']
    ['flatten.py']

下面这个例子进行了文件大小输出单位的优化:

    import os
    import sys
    
    filename = sys.argv[1]
    filesize = os.stat(filename).st_size
    
    for unit in ['字节','KB','MB','GB','TB']:
        if filesize > 1024:
            filesize = filesize/1024
        else:
            break
    
    print(filename + '大小是' +str(int(filesize)) + unit)

这个python小脚本自动输出合适的单位，具体程序逻辑还是很简单的。

#### st\_mtime属性

最后文件修改的时间。

#### st\_ctime属性

最后文件创建的时间，在windows下是严格的最初文件创建时间，在unix下是最后文件metadata的改变时间。

### 给进程发送信号

可以通过os模块的kill函数来给某个进程发送某个信号。

    os.kill(pid, sig)

函数第一个参数是进程的pid，第二个参数是具体发送的信号。比如:

    os.kill(pid, signal.SIGSTOP)

就是暂停某个进程，然后

    os.kill(pid, signal.SIGCONT)

是继续某个进程。
然后**killpg**函数能够对某个进程包括其子进程发送某个信号，参考了[这个网页](http://kernelcheck.blogspot.com/2009/07/pausestop-process-in-python.html)。

除此之外还有 **SIGINT** （正常终止进程信号）和 **SIGKILL**
（强制终止进程信号）
等等，更多信号请参看关于unix信号那块，比如[这个wiki页面](http://en.wikipedia.org/wiki/Unix_signal)
。

更多os模块内容请参见[官方文档](https://docs.python.org/3.4/library/os.html)。



os.path模块
-----------

前面提到sys.argv只能返回当前python脚本的文件名，而我们常常需要这个python脚本在系统中的具体位置。前面如os.getcwd等也能获得当前python脚本的所在目录，不过os.path模块的一个优点就是跨平台特性支持很好，也就是一般我们通过其他方式获得的path路径都会用这个模块的函数辅助处理一下。

我们来看下面的例子：

    import os
    
    print(os.path.abspath(__file__))
    print(os.path.dirname(os.path.abspath(__file__)))
    
    print(os.path.basename(__file__))
    print(os.path.basename(os.environ['HOME']))
    
    /home/wanze/桌面/test.py
    /home/wanze/桌面
    test.py
    wanze

其中`__file__`表示当前脚本文件所在的路径。

### abspath函数

abspath函数接受一个path路径值然后返回一个正规的普适的路径地址。具体效果类似于执行了:
`normpath(join(os.getcwd(), path))` 。

再看下面的例子演示了空字符串默认当前工作目录，然后也接受绝对路径等。

    >>> import os
    >>> os.path.abspath('')
    '/home/wanze'
    >>> os.path.abspath('test')
    '/home/wanze/test'
    >>> os.path.abspath('/test')
    '/test'
    >>> os.path.abspath('test/')
    '/home/wanze/test'

我们看到如果abspath接收的是空字符串，其定位是当前脚本的工作目录，那么是引用的模块里面的`os.path.abspath('')`，具体对应的也是当前脚本的工作目录。然后os.path.abspath(\".\")返回的是当前脚本工作目录。

### dirname函数

dirname函数接受一个路径值然后返回这个路径除开最后一个元素的前面的路径值。比如上面的例子，路径指向文件，那么dirname函数返回的是除开这个文件名的前面的路径；而如果接受的路径指向目录，那么返回的是除开最后一个文件夹名的前面的路径值。

### basename函数

如上面例子所示，basename函数接受一个路径值然后返回路径的最后一个元素，如果路径指向文件，那么返回的是文件名；如果路径指向目录，那么返回的是最后那个目录的文件夹名。比如下面实现了从绝对路径提取出文件名的功能。

    >>> import os.path
    >>> string = '/home/wanze/test.txt'
    >>> fileName,fileExtension = os.path.splitext(os.path.basename(string))
    >>> fileName
    'test'

### split函数

将路径path字符串分割，可以视作dirname和basename的组合。

    >>> os.path.split('/usr/local/bin/test.txt')
    ('/usr/local/bin', 'test.txt')
    >>> os.path.dirname('/usr/local/bin/test.txt')
    '/usr/local/bin'
    >>> os.path.basename('/usr/local/bin/test.txt')
    'test.txt'

### splitext函数

将某个路径path的后缀分开，这里主要是针对文件名为输入的时候，那么第一个为该文件的名字，输出数组的第二个值是该文件的后缀。这个函数在提取文件名后缀和前面的名字的时候很有用，方便组合出新的文件名。

    >>> import os
    >>> fileName, fileExtension = os.path.splitext('/path/to/somefile.ext')
    >>> fileName
    '/path/to/somefile'
    >>> fileExtension
    '.ext'

### join函数

用于连接多个路径值合并成一个新的路径值，同样相对于简单的字符串拼接，用这个函数处理路径组合具有操作系统普适性和灵活性。

    >>> os.path.join(os.path.expanduser('~'),'test','lib')
    '/home/wanze/test/lib'

上面join函数多个参数生成的新path在windows下又是不同的输出的。

### expanduser函数

    >>> import os
    >>> os.path.expanduser('~')
    '/home/wanze'
    >>> os.path.expanduser('~/pymf')
    '/home/wanze/pymf'
    >>> os.path.join(os.path.expanduser('~'),'pymf','mymodule')
    '/home/wanze/pymf/mymodule'

`~`这个符号可以在这里使用，从而展开为以/home/wanze为基础的绝对路径，兼容大部分系统（在windows下也可以使用。）

同时我们看到join函数可以接受很多不定量的参数，然后将他们组合成为一个新的路径，而且不用你费心是`/`还是`\`，你不需要写这些了，用join函数自然料理好一切。

### exists函数

os.path.exists(path)：测试路径或文件等是否存在。如果存在返回True，否则返回False。

### isfile和isdir还有islink

os.path.isfile(path)：接受一个字符串路径变量，如果是文件那么返回True，否则返回False（也就是文件不存在或者不是文件是文件夹等情况都会返回False）。

类似的有isdir和islink函数。

### samefile函数

os.path.samefile(path1,path2)：如果两个文件或路径相同则返回True\
，否则返回False。

### getmtime函数

os.path.getmtime(path)

返回文件的最后修改时间，返回值是多少多少秒，可用time模块的ctime或localtime函数将其转换成time.struct\_time
对象，然后使用strftime来进行更好的格式输出。

### getctime函数

类似getmtime，返回文件的最后创建时间。在unix系统中是指最后文件的元信息更改的时间。

更多内容请参见[官方文档](https://docs.python.org/3/library/os.path.html)。