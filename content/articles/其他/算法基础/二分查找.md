Category: algorithm
Slug: binary_search
Date: 20190909

[TOC]


## 二分查找

二分查找以前也接触过吧，当时不怎么重视，认为就是一种快速查找方法了，参看 [这个网页](https://github.com/qiwsir/algorithm/blob/master/bin_search.md) ，其认为python的 `index` 方法并不是使用的二分查找，所以对大规模查询会很吃力。考虑到python一般的sequence对象都没有预排序，所以这种说法可信度还是很高的。然后利用python的 `bisect` 模块，我们可以构建出一种预排序的支持更快查询的接口，其内部就是使用的二分查找。

二分查找的基本思想就是对于一个已经排序了的列表，如果要查找某个元素的话，则将目标列表二分为两段，目标元素和分割点的元素进行大小比较，如果目标元素比分割点的元素小，则说明列表中那个要找的元素假设存在的话那么其应该在较小的那个区段，如果较大的话则在较大的那个区段，然后逐步这样递归来缩小查找区间，直到找到目标元素具体在列表的那个位置，或者发现不在列表中。

最近在看MIT的那个视频，其中第三课讲到了利用二分查找的思想来求解平方根的问题，这个对我启发很大。尤其是那一句: 任何计算机问题如果找不到好的方法，实际上都可以穷举而得，而穷举的过程，我们不需要一个个都试一下，我们只需要将这些可能的结果集排序之后，进行二分查找来快速缩小可能的结果集，那么我们就可以逐步更快地趋近理想结果了。

这使得我认识到，二分查找思想的应用可不限于查找，而是看作一种更普遍的计算思想。本文先试着从更抽象的角度来讨论二分查找。

## 抽象的二分查找思想讨论

现在我们将可能的结果集认为是某个函数f(x)的输入参数，然后我们有目标参数target，令f(x)=target的时候我们说我们就找到了目标结果x，或者说目标x符合函数f(x)=target这个关系。然后假设我们的考察对象f(x)在目标结果集内存在简单的增减关系，即目标集合可以由此排序，那么我们就可以开展二分查找来找到目标结果x了。

以相等查找为例，f(x)函数即f(x)=x，也就是输入什么同样输出的是什么。如果x=target，则我们说目标x符合条件f(x)=target，则该x就是我们要找的目标结果x。

如果我们定义 `f(x)=x*x`，则意思是我们要找某个x符合条件 `x*x=target` ，这就是求平方根的过程。

```python

def binary_search_func(seq, target, func=lambda x: x, round_n=4, approx=True):
    """
    use binary search to solve f(x) = target problem, if the function is a
    monotonic function.

    seq  list or tuple
    target found target in which case is the f(x) = target
    func the monotonic function
    round_n accurate to how many decimal point
    approx the approx mode
    if approx=True found target or some nearly target, return it's index
    if approx=False  found target index otherwise return -1
    """
    low = 0
    high = len(seq) - 1
    count = 0
    if approx:
        target = round(target, round_n)

    while low < high:
        count += 1
        mid = (high + low) // 2

        guess = func(seq[mid])

        if approx:
            guess = round(guess, round_n)

        if guess < target:  # equal target the target also placed in big region.
            low = mid + 1
        else:  # target in low region
            high = mid

    logger.info('binary_search_func run {0} times'.format(count))
    if approx:
        return low
    else:
        return low if (low != len(seq) and seq[low] == target) else -1
```

首先我们来看最简单的查找匹配操作：

```python
def test_binary_search_func2():
    seq = list('abcdefg')
    pos = binary_search_func(seq, 'e', approx=False)
    assert seq[pos] == 'e'
```

然后我们要求平方根，也就是某个 `x*x=target` 的过程，把之前定义的函数简单改一下即可:

```python
def f(x):
    return x*x
```

然后我们利用numpy的 `arange` 函数来生成一个可能结果集。

    >>> import numpy as np
    >>> np.arange(0,10,0.1)
    array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ,
            1.1,  1.2,  1.3,  1.4,  1.5,  1.6,  1.7,  1.8,  1.9,  2. ,  2.1,
            2.2,  2.3,  2.4,  2.5,  2.6,  2.7,  2.8,  2.9,  3. ,  3.1,  3.2,
            3.3,  3.4,  3.5,  3.6,  3.7,  3.8,  3.9,  4. ,  4.1,  4.2,  4.3,
            4.4,  4.5,  4.6,  4.7,  4.8,  4.9,  5. ,  5.1,  5.2,  5.3,  5.4,
            5.5,  5.6,  5.7,  5.8,  5.9,  6. ,  6.1,  6.2,  6.3,  6.4,  6.5,
            6.6,  6.7,  6.8,  6.9,  7. ,  7.1,  7.2,  7.3,  7.4,  7.5,  7.6,
            7.7,  7.8,  7.9,  8. ,  8.1,  8.2,  8.3,  8.4,  8.5,  8.6,  8.7,
            8.8,  8.9,  9. ,  9.1,  9.2,  9.3,  9.4,  9.5,  9.6,  9.7,  9.8,
            9.9])
    >>>

然后我们有:

```python
def test_binary_search_func():
    import numpy as np
    round_n = 6
    seq = np.arange(0, 10, 10 ** (-round_n))

    mid = binary_search_func(seq, 2, func=lambda x: x * x, round_n=6,
                             approx=True)

    assert pytest.approx(seq[mid]) == 1.414214
```



## bisect模块

bisect模块提供了二分查找的支持，比如bisect_left函数：

```python
def bisect_left(a, x, lo=0, hi=None):
    """Return the index where to insert item x in list a, assuming a is sorted.
    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will
    insert just before the leftmost x already there.
    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x: lo = mid+1
        else: hi = mid
    return lo
```

其底层有c加速，然后其返回的是一个索引值，根据这个索引值，如果你执行 `a.insert(x)` ，那么将把目标值插入到目标位置，如果x已经在a中存在，则插入的是最左边的位置。于是我们有：

```python
def binary_search(seq, target):
    """
    use the bisect_left.
    """
    pos = bisect_left(seq, target)
    # pos == len(seq) means the target is bigger than all the elements of seq
    # other pos value is a valid index in seq
    # So if x already appears in the list, a.insert(x) will
    # insert just before the leftmost x already there.
    return pos if (pos != len(seq) and seq[pos] == target) else -1
```



## iter_search

在这里讲个题外话，提到可能结果集的时候，我就想到将多个函数参数作为(a,b,c)这种形式，可是这种多元函数问题，怎么排序，怎么比较大小，怎么确定增减性？所以只好回滚到最原始的穷举过程。

比如说孙子算经里面的:

> 今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？

穷举的基本函数是:

```python
def iter_search(f,seq,target):
    for item in seq:
        if f(item) == target:
            yield item
```

很简单的一个函数，很简单的逻辑，但实际上这种先迭代某个对象，然后找到某个对象复合某个条件，则返回某个对象的过程在程序模式里面是非常常见的。

然后我们根据笛卡尔积生成可能结果集:

    >>> from itertools import product
    >>> seq = list(product(range(35),range(35)))
    >>> seq
    [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), ..............
    .............

然后我们可以很直观的将问题化为两个满足条件来对可能结果集进行过滤操作:

    def f(d):
        x = d[0]
        y = d[1]
        head = x + y
        return head
    
    def g(d):
        x = d[0]
        y = d[1]
    
        foot = 2*x + 4*y
        return foot

然后我们有:

    res = list(product(range(35),range(35)))
    res = iter_search(f,res,35)
    res = iter_search(g,res,94)
    print(list(res))
    
    [(23, 12)]



