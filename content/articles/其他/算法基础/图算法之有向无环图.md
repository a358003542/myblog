Category: algorithm
Tags: algorithm
Slug: directied-acyclic-graph
Date: 20190910

[TOC]

## 前言

**有向无环图** ，英文缩写是 DAG，（directied acyclic graph）。其是在有向图的基础上加入了**无环**这个判断条件。所谓无环指在该有向图从任意顶点出发经过若干条边之后都无法回到该顶点。

一开始我最先接触 DAG 这个术语，是在找工作流软件的时候，工作流的通用表示方法就是用 DAG 来表示。为什么？假设你是工作流中的某个节点的员工，你按照某个workflow走下去，最后闭环了，然后你无限循环在某个流程中了，那可真蠢了。

然后比如说 git 的版本控制，其内部版本控制流程也是用的有向无环图，如果你版本修改修改，又回到某个老版本了，那版本控制也失效了。

聪明的朋友肯定想到了我们的宇宙时间是不可逆的，也就是说如果用模型来表示宇宙所有的信息数据变动流结构的话，那么一定是有向无环图。

在之前的 [图算法建模初步]({filename}./图算法建模初步.md) 一文中我们已经实现了有向图 `DirectedGraph` 类，在该类的基础上只需要加上额外的无环判断操作即可。

图论里面关于这个已经有算法了，我们也没什么好想的，就是图论的拓扑排序方法来判断一个有向图是否是无环的。

wiki上有伪代码，我们可以下看一下：

```
L ← Empty list that will contain the sorted elements
S ← Set of all nodes with no incoming edge
while S is non-empty do
    remove a node n from S
    add n to tail of L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
if graph has edges then
    return error (graph has at least one cycle)
else 
    return L (a topologically sorted order)
```

这个算法叫做 Kahn 算法，具体思路就是请读者假想目标研究有向图里面有一个闭环，那么这个闭环里面的所有节点都有进入箭头的，也就是其不可能在set S，其在算法中只可能在 m 中被选中，而且闭环中的节点一定不会出现在n中，这样上面的算法再怎么运算，if语句对于闭环中的m来说都不会成立。

然后假设某几个节点都有入口，那么顺藤摸瓜，逐个删除是可以把这些节点都放到S里面去的。

我心里还有一个担心，也就是上面的算法的终止问题，主要是闭环那边。初步的判断是闭环内的节点m不会进入S，其他节点慢慢会被放入L。OK，让我们开始写代码，然后再实际看一下吧。



## 基本实现

该类继承自有向图类，然后修改增加边的动作，加上sort无环判断，如果发现增加一个边之后图有环了，那么将移除该边，并抛出异常。

就sort方法的实现来说基本上就是上面提及的wiki的伪代码的实际实现：

```python
class DirectedAcyclicGraph(DirectedGraph):
    def add_edge(self, edge):
        """
        add acyclic judgement.
        """
        super().add_edge(edge)

        if not self.sort():
            self.remove_edge(edge)
            raise NotAcyclicError

    def remove_edge(self, edge):
        """
        remove edge start -> end
        """
        start, end = edge
        super(DirectedAcyclicGraph, self).del_edge((start, end))

        # clear data
        if self.in_degree(start) == 0 and self.out_degree(start) == 0:
            if start in self.graph_data:
                del self.graph_data[start]

        if self.in_degree(end) == 0 and self.out_degree(end) == 0:
            if end in self.graph_data:
                del self.graph_data[end]

    def sort(self):
        """
        L ← Empty list that will contain the sorted elements
        S ← Set of all nodes with no incoming edge
        while S is non-empty do
            remove a node n from S
            add n to tail of L
            for each node m with an edge e from n to m do
                remove edge e from the graph
                if m has no other incoming edges then
                    insert m into S
        if graph has edges then
            return error (graph has at least one cycle)
        else
            return L (a topologically sorted order)
        """
        target = deepcopy(self)
        top_order = []

        queue = deque()
        for k in target.nodes():
            if target.in_degree(k) == 0:
                queue.append(k)
                logger.debug('queue append {0}'.format(k))

        while queue:
            n = queue.pop()
            top_order.append(n)

            for m in self.neighbors(n):
                target.remove_edge((n, m))
                logger.debug('remove n->m {0} {1}'.format(n, m))
                if target.in_degree(m) == 0:
                    logger.debug('append {0}'.format(m))
                    queue.append(m)

        if len(top_order) != len(self.nodes()):
            return False
        else:
            return top_order
```







