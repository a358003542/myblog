Category: algorithm
Tags: algorithm
Slug: greedy-algorithm
Date: 20191018

[TOC]

任何问题总可以通过暴力穷举算法求解，当然有些问题组合数情况太多了，尤其是某些问题，没有快速算法，即NP完全问题。那么可以试着用一些近似算法来快速找到一个近似解。贪婪算法就是其中的一个近似解。

贪婪算法并不是某种具体的算法，更像是写算法时的一种思路参考。如果你要解决问题，而该问题可以分解为多个步骤，那么你可以通过寻找每步的局部最优解，来**近似**得到目标问题的全局最优解。（贪婪算法并不保证你得到的解一定是全局最优解，但一般这个解是很靠近全局最优解了。）

对于一个问题，如果贪婪算法是有效的，那么一般贪婪算法就是解决这个问题最好的算法。



## 背包问题



```python

class Knapsack(object):
    def __init__(self, capacity, items=None):
        self.capacity = capacity
        self.items = [] if items is None else items
        self.freespace = self.capacity

    def add_item(self, item):
        if self.freespace - item.weight >= 0:
            self.freespace -= item.weight
            self.items.append(item)
            return True
        else:
            return False

    def all_items_value(self):
        value = 0
        for item in self.items:
            value += item.value
        return value

    def __repr__(self):
        return '<Knapsack: {0}>'.format(self.items)


class Item(object):
    def __init__(self, name, value, weight):
        self.value = value
        self.weight = weight
        self.name = name

    def __repr__(self):
        return '<Item: {0}>'.format(self.name)

    def __eq__(self, other):
        if self.name == other.name and self.value == other.value and self.weight == other.weight:
            return True
        else:
            return False



def greedy_algorithm(knapsack, items):
    """
    贪婪法求解
    :return:
    """
    items_copy = items.copy()
    found = True

    while found:
        max_value = 0
        choosed_item = None
        for item in items_copy:
            if item.value > max_value:
                choosed_item = item
                max_value = choosed_item.value

        if knapsack.add_item(choosed_item):
            found = True
            items_copy.remove(choosed_item)
        else:
            found = False
    return knapsack
```

上面的版本还可以扩展出比较函数是比较最小重量或者最大价值/重量比，总的说来这里理解贪婪算法基本思想即可。



## 参考资料

- 算法图解 Aditya Bhargava 著



