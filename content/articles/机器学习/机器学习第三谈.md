Title: 机器学习第三谈
Slug: machine-learning-talk-three
Date: 2018-11-06
Modified: 2018-11-06
Tags: machine-learning

[TOC]

## 前言

在上一文机器学习第二谈中，我们算是搭建了一个简单的神经网络，初步了解了一下大体情况。本文主要紧跟着对相关内容进行更细致的讨论。



## relu激活函数

relu激活函数具体的数学运算公式很简单，就是：

```
z = np.maximum(z, 0)
```

上面运算就是对z张量进行了relu运算了，按元素的，如果元素值大于0则为原元素的值，否则为0。



## 广播(broadcasting)

广播一种操作，shape较小的张量和shape较大的张量进行点对点运算时，需要对shape较小的张量进行广播操作，使其在运算上shape兼容。

广播具体操作规则是：

- shape较小的张量添加新的维度是的两个张量维度数相同

- shape较小的张量在新的维度中的数据是重复的，相当于没有原维度的数据，即： y[1,j] = y[2,j] = y[3,j] =... y[j]

## 张量点积

矩阵乘法也就是这里的张量点积学过线性代数的对这个概念还是很清楚了，不过到更高的维度的张量的点积情况似乎有点复杂了。这里我们需要把张量点积的shape变化弄清楚，后面可能会有用的，具体实际张量运算可以交给函数去做。


$$
x \cdot y = z
$$
x shape (a, b) y shape (b,c) 输出 z的 shape(a, c) 

高维的情况如下：

(a, b, c ,d) · (d,) -> (a,b,c)

(a, b, c ,d) · (d, e) -> (a,b,c, e)



## 张量变形

ndarray可以直接调用reshape方法来进行张量变形操作，变形后元素总个数应该不变，也就是各个维度容量乘积数不变。

## 张量的导数

张量的导数叫做梯度。



## 随机梯度下降(SGD)

小批量SGD过程如下：

1. 抽取训练样本x和对应目标y组成数据批量
2. 在x上运行网络，得到预测值y_pred
3. 计算网络在这批数据上的损失，用于衡量y_pred和y之间的距离
4. 计算损失相对于网络参数的梯度
5. 将参数沿着梯度的反方向移动一点 W -= step * gradient ，从而使这批数据上的损失减小一点。这里的step即步长也叫学习率。

目前实践中的优化器optimizer都采用的是随机梯度下降，不同的是各自进行了某些优化，这些SGD变体有：带动量的SGD，Adagrad，RMSProp等。

## 二分类问题

imdb电影评论二分类问题，输出评论文字，然后得出评论积极还是消极。



### 准备数据

imdb电影评论的数据，其内部建立了一个字典索引，某个整数对应某个单词。

具体某一个评论是一个整数序列，下面有两种方法将这个整数序列张量化：

1. 填充或截取，使得每个整数序列具有相同的长度，然后神经网络第一层必须是 Embedding 层。
2. 对列表进行one-hot编码，比如说[3,5]在长度10的情况下编码为 [0,0,1,0,1,0,0,0,0,0] ，然后第一层使用Dense层，这个前面提到过了。

### 验证集

在model.fit 里面你可以通过 `validation_data` 参数来指定验证集，验证集和训练模型无关，是一个epoch之后来运算验证当前模型的效果，可以及时发现模型出现过拟合问题或者其他问题，从而决定是否终止训练模型。

你可以从训练集里面切一部分下来作为训练集，也可以直接使用测试集作为验证集【这里简单起见就直接用测试集做了验证集，正式的做法叫做留出验证集法，是应该操作如下：训练数据里面一部分作为训练集，剩下来的一部分作为验证集，然后用训练集训练，验证集评估当前模型的好坏。模型参数调节好训练好之后，记得最后用整个训练集从头训练一次，最后用另外的测试集数据测试下模型的实际效果】。

```
from keras.datasets import imdb
import numpy as np
(train_data, train_labels),(test_data, test_labels) = imdb.load_data(num_words=10000)
y_train = np.asarray(train_labels).astype('float32')
y_test = np.asarray(test_labels).astype('float32')
```

```
word_index = imdb.get_word_index()
reversed_word_index = dict([value,key] for key,value in word_index.items())
decoded_review = ' '.join([reversed_word_index.get(i-3, '?') for i in train_data[0]])
decoded_review
```

这里采用的是one-hot编码，值得注意的是一句话如果有几个重复的单词，将是被忽略的，第一种方案填充截取方案会保留词语顺序，这个在自然语言处理中是很重要的一个因素。

```python
import numpy as np
def verctorize_sequences(sequences, dimension=10000):
    results = np.zeros((len(sequences), dimension))
    for i, sequence in enumerate(sequences):
        for d in sequence:
            results[i, d] = 1
    return results
```

```
x_train = verctorize_sequences(train_data)
x_test = verctorize_sequences(test_data)
```

```
from keras.models import Sequential
from keras.layers import Dense,Dropout
from keras.optimizers import RMSprop
model = Sequential()
model.add(Dense(16, activation='relu', input_shape=(10000,)))
model.add(Dense(16, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.summary()
```

```
model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])
```

```
history = model.fit(x_train, y_train, epochs=4, batch_size=512, validation_data=(x_test, y_test))
```

### history作图

keras出来的history并没提供作图函数，下面简单整理了一下：

```python
import matplotlib.pyplot as plt

def plot_history_loss(history):
    acc = history.history['acc']
    val_acc = history.history['val_acc']
    loss = history.history['loss']
    val_loss = history.history['val_loss']

    epochs = range(1, len(acc) + 1)

    # "bo" is for "blue dot"
    plt.plot(epochs, loss, 'bo', label='Training loss')
    # b is for "solid blue line"
    plt.plot(epochs, val_loss, 'b', label='Validation loss')
    plt.title('Training and validation loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()

    plt.show()
    
plot_history_loss(history)
```

```python
def plot_history_acc(history):
    acc = history.history['acc']
    val_acc = history.history['val_acc']

    epochs = range(1, len(acc) + 1)
    plt.plot(epochs, acc, 'bo', label='Training acc')
    plt.plot(epochs, val_acc, 'b', label='Validation acc')
    plt.title('Training and validation accuracy')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()

    plt.show()
    
plot_history_acc(history)
```

这个基本上ephch超过2,3之后就开始过拟合了，但是精度没有超过90%的。Keras中的example相关看了一下，就算使用CNN提升也不是很明显，倒是用了数据预处理这块使用了二元模型，准确度稍微提升了一点，可见就imdb这个例子，必须加上自然语言处理相关的数据预处理步骤才能更好地提升准确度。



### 总结

1. 使用验证集和绘图能够很好地观察过拟合现象，这个不能省，最后测试集环节省了验证集也不要省。
2. 二分类问题最后一层激活函数推荐 sigmoid，损失函数推荐 binary_crossentorpy
3. relu激活的Dense层堆叠，可以解决很多问题。
4. 无论问题是什么，rmsprop优化器通常都是一个好的选择。



## 多分类问题

将某个数据点划分为某一个类别，但是有多个分类的问题是单标签多分类问题；如果某个数据点可以划分为多个分类，则为多标签多分类问题。

多分类问题在处理上和二分类问题很类似，除了一些细节上的差异：

1. 标签数据张量化可以使用 `to_categorical` 来进行one-hot编码，然后损失函数需要选择 `categorical_crossentropy` 。或者标签数据直接作为整数标签转成ndarray对象送入，这时需要选择损失函数 `sparse_categorical_crossentropy` ，这两者只是接口差异，内部算法一样的。
2. 多分类问题神经网络最后一层应该是对应N个分类的N个units的Dense层。
3. 多分类问题神经网络应该避免使用太小的中间层，以免出现信息瓶颈。



## 回归问题

回归问题预测是连续的值而不是离散的标签。

### 取值范围差异很大的数据

取值范围差异很大的数据送入神经网络需要先进行标准化处理。这里指的标准化是正态分布那边的概念，也就是计算每个特征值的z-score标准分。即 每个特征值减去本特征的平均值然后除以本特征的标准差。

```
mean = train_data.mean(axis=0)
```

这是计算维度0的均值，或者说是计算每个特征列的均值。减去操作如下：

```
train_data -= mean
```

这里往细上将还进行了mean的广播操作，所以才能按照元素点对点的执行了减法操作。

这是计算每个特征列的标准差：

```
std = train_data.std(axis=0)
```

**注意：** 用于测试数据标准化的均值和标准差都是训练数据上的。在工作流程上，你不能从测试数据上计算得到任何结果。



### K折验证

如果可用数据较少，可以使用K折验证来可靠地评估模型。

K折验证是将验证数据分成K分，重复K次，每次选取一个作为测试集，其他作为训练集。模型的最终验证分数等于K个验证分数的均值。



### 总结

1. 回归问题神经网络最后一层没有激活函数，可以返回任意范围内的值。
2. 回归问题常用损失函数：mse损失函数。MSE（mean squared error） 均方误差损失函数。
3. 回归问题监控指标：平均绝对误差。MAS （mean absolute error）是预测值和目标值之差的绝对值。
4. 如果可用的训练数据较少，最好使用隐藏层较少的小型网络，避免严重的过拟合





## 参考资料

1. 机器学习实战 Peter Harrington 著 李锐 李鹏等译
2. [机器学习实战线上教程](http://ml.apachecn.org/mlia/)
3. python深度学习 弗朗索瓦·肖奈