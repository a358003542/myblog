Title: django后台api编写之-模型的定义和使用
Date: 2018-05-26

[TOC]
## 模型的定义和使用

django的模板和sqlalchemy还是有很多地方类似的。

## settings那边的配置
-   **INSTALLED\_APPS:** 你需要加上你新加入的 app 的名字，不加的话是不能通过 `makemigrations` 来管理数据库的。

-   **DATABASES:** 默认会创建一个sqlite3数据库，也能满足基本的需求了，如果你想要使用mysql等数据库，则参考样例修改这里的配置。比如连接mysql的样例是:

```
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': "database_name",
            'USER': "root",
            'PASSWORD': "",
            'HOST': "localhost", 
            'PORT': "3306",
            'OPTIONS': {
                'charset': 'utf8'
            }
        }
    }
```

一般会加上 charset 是 utf8这个选项，当然mysql那边你也需要设置好字符编码。有的时候如下设置init_command 来设置字符编码可以让你获得更好的字符编码兼容性。

```
    'OPTIONS': {
        'init_command': 'SET character_set_database=utf8 ,\
        character_set_server=utf8,\
        character_set_connection=utf8,\
        collation_connection=utf8_unicode_ci',
        'charset': 'utf8'}
```

### 使用多个数据库
有的时候你需要使用多个数据库，最常见的情况是某个单独的app使用另外一个数据库。

首先你需要再加上另外一个数据库的定义：

```
    DATABASES = {
        'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': "database_name",
        'USER': "root",
        'PASSWORD': "",
        'HOST': "localhost",
        'PORT': "3306",
        'OPTIONS': {
            'charset': 'utf8'
            }
        },
        'youapp': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'youapp',
            'USER': 'root',
            'PASSWORD': '',
            'HOST': '',
            'PORT': '',
            'OPTIONS': {'charset': 'utf8'}
        },
    }
```
然后在你的app那边新建一个dbrouter文件，里面定义一个YourRouter类。

```
DATABASE_ROUTERS = ['youapp.dbrouter.YourRouter']
```
在这个类里面如下定义一些数据库选择行为：

**NOTICE: 在这个app中定义的模型记得都要加上app_label这个meta属性。**

```
class YourRouter(object):
    def db_for_read(self, model, **hints):
        if model._meta.app_label == 'youapp':
            return 'youapp'
        return None

    def db_for_write(self, model, **hints):
        if model._meta.app_label == 'youapp':
            return 'youapp'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        if obj1._meta.app_label == 'youapp' or \
            obj2._meta.app_label == 'youapp':
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if app_label == 'youapp':
            return db == 'youapp'
        return None
```



## 定义模型
好了，开始实际定义自己的模型了。首先基本语法如下:
```python
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')
```

这个熟悉sqlalchemy的对这段代码不会很陌生，下面进一步了解一些细节吧。

### 字段类型

- **IntegerField:** 整型
- **BigIntegerField:** 大整数
- **BinaryField:** raw data
- **BooleanField:** bool 值

- **CharField:** 定义字符串类型，比如设置最大长度 `max_length` 这个属性。
- **TextField:** 大段文字用这个。
- **DateField:** 对应python中的 `datetime.date` 对象。
- **DateTimeField:** 对应python中的 `datetime.datetime` 对象。

一个有用的基类:

```python
class BaseModel(models.Model):
    class Meta:
        abstract = True

    updated_at= models.DateTimeField(auto_now=True)
    created_at= models.DateTimeField(auto_now_add=True)
```

后面的模型都可以继承自该基类，基类是不会创建表格的，因为其Meta设置了 `abstract=True` 。DateTimeField加上 `auto_now=True` ，那么该模型每次 `save` 操作都会自动更新最新日期。 然后 `auto_now_add=True` 即该记录第一次创建时设置最新的日期。然后如果DateTimeField使用了 auto_now 或者 auto_now_add 这两个选项了就不要使用default选项了，还有就是自动插入的默认的时间是由 `django.utils.timezone.now()` 获得的。

比如后面你想获得六个小时之前的所有记录那么可以如下查询：

```
    checktime = timezone.now() - timedelta(hours=6)
    result = result.exclude(created_at__gt= checktime)
```


### 通用选项
字段声明控制中有一些通用可选项:

- **default:** 设置该字段的默认值，注意default还可以接受一个函数对象。
- **null:** 设置为True，则该自动会自动填充sql中的NULL值，字符串类型字段最好默认空字符。
- **blank:** 如果设置为True，则空值也是允许的，其和null的区别是null是说数据库那边的，而blank是说显示那边的。

- **db\_column:** 设置该字段具体在数据库中对应的表格的名字。

- **db\_index:** 设置为 `True` 则表示该字段开启索引。

- **primary\_key:** 主键 。

- **unique:** 唯一
- **unique\_for\_date:** 比如title字段设置:

```
    unique_for_date="pub_date"
```
则 title字段和 pub\_date 字段都不能相同。也就是在某个日期内某个title只能有唯一值。可以看作一种 `unique_together` 的应用。


### 数据库中的关系
**ForeignKey:** 外键引用，如果该字段的名字是user，那么实际存储在表格中的名字是user\_id，你可以通过 `db_column` 来实际控制该表格的名字。- 

我们通常说的onetomany关系就是通过定义ForeignKey来获得的。比如：

```
class City(models.Model):
     name = models.CharField(max_length=60)
     state = models.CharField(max_length=40)
     zipcode = models.IntegerField()

class Address(models.Model):
     number = models.IntegerField()
     street = models.CharField(max_length=100)
     city = models.ForeignKey(City)
```
一个city有多个address，但是一个address只能有一个city，也就是一个外键映射到city那边。所以我觉得ForeignKey更确切的表示是manytoone关系，当某个模型有一个外键属性是，也就是可以有多个记录指向同一个它物 [参阅了这篇文章](https://chrisbartos.com/articles/how-to-implement-one-to-many-relationship-in-django/)。

**OneToOneField**
OneToOneField 比较简单，就是一个记录只有一个对应的属性，通常在用户管理的时候会用到。


**ManyToManyField**

ManyToManyField 读者请参阅我写的 [sqlalchemy模块](http://www.cdwanze.work/articles/python/sqlalchemy-module.html#orm_2) 一文， 那里写得比较详细。




关于模型定义的字段，更多的内容请参看官方文档。



### 多字段组合唯一

参考了 [这个网页](https://stackoverflow.com/questions/28712848/composite-primary-key-in-django) ，具体就是在 `Meta`  那里定义 `unique_together` 属性。

```
    ...
    title = models.CharField(max_length=255)
    gzh_id = models.CharField(max_length=255, null=True, blank=True)
    ...
   class Meta:
        db_table = 'article'
        unique_together = ("title","gzh_id")
```



## 定义模型中的元类数据

```
    ...
    class Meta:
        db_table = 'table_name'
```

- db_table 具体指定实际创建的table表格的名字。
- abstract 将不会创建表格，该模型为抽象模型。
- 



## 模型的使用

模型的使用最核心的部分就是查询操作，至于修改记录，则具体查询获得目标记录了，修改属性然后save即可。

### 新建记录
```
from people.models import Person
Person.objects.create(name="WeizhongTu", age=24)
```

但是要注意如果你插入一条记录出现主键重复问题了，那么程序是会返回异常的。一般推荐使用 `get_or_create` 方法：

```
obj, created = Person.objects.get_or_create(first_name='John', last_name='Lennon',
                  defaults={'birthday': date(1940, 10, 9)})
```
上面这个语句有查询的效果也有新建记录的效果。写的这些属性首先将进行get操作，大体是如下的加强版：

```
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
except Person.DoesNotExist:
    obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
    obj.save()
```

而如果单纯使用get方法，如果记录不存在那么会抛出 **DoesNotExist** 异常；如果找到多个记录，会抛出 **MultipleObjectsReturned ** 异常。 get_or_created 方法如果找到多个记录也会抛出  **MultipleObjectsReturned ** 异常。

这样 `get_or_created ` 方法将确保总是插入一条记录或者取得记录。其中created=True则表明target是新建的记录。

然后是如何理解 defaults 这样选项，defaults里面定义的属性不会参与get查询过程，其参与的是在没有找到记录的情况下，设置某些值。


### 查询记录
首先说一下获取所有的记录：
```
result = Person.objects.all()
```
其返回的是 QuerySet 对象，QuerySet对象可以继续进行下一步的查询操作。比如下面可以继续：

```
result = result.filter(name="abc")
```
当然就上面的例子来说直接使用filter方法即可：

```
result = Person.objects.filter(name="abc")
```



### 排序

QuerySet对象可以进一步排序：

```
result = result.order_by('what')
```

### reverse

```
result = result.reverse()
```

### exclude
排除某些记录，下面是排除created_at这个字段值大于某个时间的值：
```
result = result.exclude(created_at__gt= checktime)
```

### offset and limit

```
result = result[offset: offset+limit]
```



### 删除某个记录

找到目标记录的instance，然后调用 `delete` 方法即可。

### 确定某记录是否存在

前面已经谈到了一些查询操作，而如果读者只是单纯的想确定某记录是否存在，那么使用 `exists` 方法是最快和最简便的。参考了 [这个网页](https://stackoverflow.com/questions/2690521/django-check-for-any-exists-for-a-query) 。



```
if Article.objects.filter(unique_id= unique_id).exists():
    ...
```

### 关系的使用

OnetoOne关系的使用非常简单， `a.b` 或者 `b.a` 都是可以的。

ManytoOne关系也就是由 ForeignKey 定义的关系，如果是引用外键的那个对象，那么直接 `a.b` 即可，如果是反向onetomany那种，则最好你在定义的时候就定义好 `related_name` ，（参考了 [这个问题](https://stackoverflow.com/questions/19799955/django-get-the-set-of-objects-from-many-to-one-relationship) ）那么引用如下：

```
b.related_name
```

具体使用细节还是请查看文档的 [这里](https://docs.djangoproject.com/zh-hans/2.0/topics/db/examples/many_to_one/) 。