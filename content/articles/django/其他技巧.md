Title: django后台api编写之-其他技巧
Date: 2018-05-26

[TOC]

## 其他技巧

### 模型python2兼容性
为了提高模型python2兼容性，推荐模型定义上加个如下装饰器。

```
from django.utils.encoding import python_2_unicode_compatible


@python_2_unicode_compatible 
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text
```
以前不加这个装饰器，python2之前用的是 `__unicode__` 方法。


### 重置migrations
一般的方法把migrations文件删掉，把表格删掉并不能成功，因为他们忽视了django_migrations这个表格里面的数据（参考了 [这个网页](https://stackoverflow.com/questions/23755523/how-to-reset-migrations-in-django-1-7)）。

如果你把 `django_migrations` 里面的对应app的迁移数据删掉，然后再makemigrations和migrate，那么就更重新开始的一样。

```
python manage.py makemigrations app_name
python manage.py migrate app_name
```
### 处理列表对象

我们需要自定义一个model的新Field对象来解决这个问题，具体就叫做ListField。

```

def parse_to_python(value):
    try:
        value = ast.literal_eval(value)
        return value
    except Exception as e:
        rasie ValidationError


class ListField(models.TextField):
    """
    存储python列表对象
    """
    description = _("Stores a python list")

    def __init__(self, *args, **kwargs):
        super(ListField, self).__init__(*args, **kwargs)

    def to_python(self, value):
        if value is None:
            value = value

        if isinstance(value, list):
            return value

        return parse_to_python(value)

    def get_prep_value(self, value):
        if value is None:
            return value

        value = six.text_type(value)
        return value

    def value_to_string(self, obj):
        value = self.value_from_object(obj)
        return self.get_prep_value(value)

    def from_db_value(self, value, expression, connection, context):
        if value is None:
            return value

        return parse_to_python(value)

```

-   `from_db_value` 当数据从数据库里面读取出来，总会调用这个方法。包括（including in aggregates and [`values()`](https://docs.djangoproject.com/en/1.11/ref/models/querysets/#django.db.models.query.QuerySet.values) calls。 所以这是最重要最核心的一个定制方法，其含义是很明显的，不用多说了。

    ---

这四个方法大体如下流程：

```
python  <- to_python  <-   from_db_value<- database

python ->value_to_string -> get_prep_value -> database

```

**NOTICE** 上图主要是方便读者理解，实际上django并不是这样逐个处理的。按照官方文档的说法 `to_python` 和django的反序列（deserialization ）有关，其还必须处理好三种情况：None，目标对象，字符串情况。

`value_to_string` 和序列化有关，和`to_python` 是相对的。`get_prep_value` 和我们在输入get(what='20170809') 执行查询是有关，讲过其转化成为sql实际查询中用到的字符串（比如说datetimefield）就做了一些额外的处理工作。 



### 多数据库处理

一个django项目里面可能因为某些原因，某些app需要单独操作另外的数据库，这种情况你首先在 `settings` 那里定义好数据库的配置：

```
    DATABASES = {
        'default': {
			...
        },
        'newdb': {
            'ENGINE': 'django.db.backends.mysql',
			...
        },
```

然后加上这个dbroute对象：

```
DATABASE_ROUTERS = ['articles.dbrouter.ArticlesRouter']
```

然后在你的app那里定义好dbroute对象：

```django
class ArticlesRouter(object):
    def db_for_read(self, model, **hints):
        if model._meta.app_label == 'articles':
            return 'articles'
        return None

    def db_for_write(self, model, **hints):
        if model._meta.app_label == 'articles':
            return 'articles'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        if obj1._meta.app_label == 'articles' or \
            obj2._meta.app_label == 'articles':
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if app_label == 'articles':
            return db == 'articles'
        return None
```

从上面的代码可以看出来，你定义的模型 `Meta` 那里必须定义好 `app_label` 属性。更多信息请参看官方文档的 [这里](https://docs.djangoproject.com/en/1.11/topics/db/multi-db) 。

### 如何根据django的模型对象来获取其对应的表格的名字

参看 [这个网页](http://stackoverflow.com/questions/233045/how-to-read-the-database-table-name-of-a-model-instance) 。

答: 

    model_instance._meta.db_table

### 如何使用好django的ImageField

参考了 [这篇文章](http://gregblogs.com/django-saving-an-image-using-imagefield-explain-a-little/) 。

ImageField和FileField很类似，除了还多了 `width` 和 `height` 属性，然后就是在上传的时候确保文件是图片文件。

具体在模型文件中的定义如下:

    banner = models.ImageField(upload_to=game_2048_images, blank=True,
                               storage=OverwriteStorage(), default="placeholder.jpg")

上面的 `upload_to` 是控制图片在计算机中的保存路径，可以直接指定一个文件夹路径，但这通常不够灵活，这里通过一个函数来实现更加灵活的路径指定:

    def game_2048_images(instance, filename):
        """
        where image upload to.
        """
        return 'game/2048/images/{}/{}'.format(instance.user.username, filename)

这里具体路径是根据你在 `settings` 里面指定的 `MEDIA_ROOT` 而来，然后再指定里面的具体的文件夹路径。我们看到函数还可以接受具体模型对应的实例，从而建立自动根据user用户名来分配不同的文件夹路径。

`storage=OverwriteStorage()` 实现了如果文件名重复则覆盖的逻辑:

    class OverwriteStorage(FileSystemStorage):
        '''
        存储文件或图片，如果文件名重复则覆盖。
        '''
    
        def get_available_name(self, name):
            if self.exists(name):
                os.remove(os.path.join(settings.MEDIA_ROOT, name))
            return name

ImageField 可以和rest\_framework的序列化类形成很好的联动，最后序列化之后返回的是文件路径url字符串，测试的时候我们可以如下用django来挂载这些静态资源文件，实际运营的时候则推荐用nginx怎么设置一下url分发。

    from django.conf.urls.static import static
    from django.conf import settings
    
    if settings.DEBUG:
        urlpatterns += static('/data/', document_root=settings.MEDIA_ROOT)

在保存传过来的图片文件的时候，常规构建form对象也是可行的:

    form = Game2048InfoForm(
        request.POST, request.FILES, instance=target_info)
    
    if form.is_valid():
        new_game_info = form.save()
    else:
        logger.warning('form invalid')

否则你需要通过:

    request.FILES['imgfield']

这样的语法来获取图片内容。

### django的messages系统

本小节主要参看了 [这个网页](https://www.webforefront.com/django/setupdjangomessages.html) 。

使用django的messages系统，首先需要如下所示在settings里面进行一些配置：

    INSTALLED_APPS = [
        'django.contrib.messages',
        ......
    
    MIDDLEWARE_CLASSES = [
        'django.contrib.messages.middleware.MessageMiddleware',
        ......
    
    TEMPLATES = [
        {
             'OPTIONS': {
                'context_processors': [
                    'django.contrib.messages.context_processors.messages',
                    ......

然后在views那边，使用 `messages.add_message()` 来往django信息系统里面发送一个信息，此外还有如下的这些快捷方法：

-   messages.debug()
-   messages.info()
-   messages.success()
-   messages.warning()
-   messages.error()

你还可以如下设置每个request请求下的信息系统级别：

    from django.contrib import messages
    messages.set_level(request, messages.DEBUG)

下面我定义了一个简单的flash函数

```python
def flash(request, title, text, level='info'):
    """
    利用django的message系统发送一个信息，对接模板的sweetalert。
    """
    level_map = {
        'info': messages.INFO,
        'debug': messages.DEBUG,
        'success': messages.SUCCESS,
        'warning': messages.WARNING,
        'error': messages.ERROR
        }

    level = level_map[level]

    messages.add_message(request, level, text, extra_tags=title)
    return 'ok'
```

之所以做这样的封装是为了更好地对接sweetalert这个javascript库，然后模块加入如下内容从而从而实现信息的具体弹出行为。

    {% if messages %}
    <script src="{% static 'js/sweetalert.min.js' %}"></script>
    <script>
    {% for msg in messages %}
        sweetAlert({
            title: '{{msg.extra_args}}',
            text: '{{ msg.message }}',
            type: '{{ msg.level_tag }}',
          })
    {% endfor %}
    </script>
    {% endif %}