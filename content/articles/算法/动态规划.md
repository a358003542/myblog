Title: 动态规划
Slug: dynamic-programming
Date: 2018-08-26
Modified: 2018-08-26
Status: draft
[TOC]

动态规划算法和贪婪算法思路有点类似，也是将某个大问题分成一些离散的小问题，然后通过小问题的解决来综合解决大问题。贪婪算法只是获得一个近似解，动态规划算法是获得的确定解。最简单的算法就是尝试各种组合情况，而如果一个问题可以用动态规划算法来解决，那么是比朴素解法要好的。

动态规划算法和贪婪算法一样，更多的是提供一个解决具体问题的思路。

动态规划算法一开始就是分析问题，然后试着绘制一个网格，目标网格的每个单元格具有相同的操作模式，然后每个问题都可以分成一系列的单元格，也就是子问题。

## 背包问题

下面代码写法稍显复杂，为的是记录好最终的结果。总的思路就是新加入一个item，如果没有更大的value，那么不进行操作，如果引入了更大的value，那么就使用这个item，如果还有多余的空间，那么剩下来的空间由剩下来的item处理，这个之前肯定有数据了。

```python

import pandas as pd


class Knapsack(object):
    def __init__(self, capacity, items=None):
        self.capacity = capacity
        self.items = [] if items is None else items
        self.freespace = self.capacity

    def add_item(self, item):
        if self.freespace - item.weight >= 0:
            self.freespace -= item.weight
            self.items.append(item)
            return True
        else:
            return False

    def all_items_value(self):
        value = 0
        for item in self.items:
            value += item.value
        return value

    def __repr__(self):
        return '<Knapsack: {0}>'.format(self.items)


class Item(object):
    def __init__(self, name, value, weight):
        self.value = value
        self.weight = weight
        self.name = name

    def __repr__(self):
        return '<Item: {0}>'.format(self.name)

    def __eq__(self, other):
        if self.name == other.name and self.value == other.value and self.weight == other.weight:
            return True
        else:
            return False


def dynamic_programming(knapsack, items):
    """
    动态规划法求解
    :return:
    """
    len_i = len(items)
    len_j = knapsack.freespace

    df = pd.DataFrame(index=[item.name for item in items], columns=range(1, len_j + 1))
    for i in range(len_i):
        for j in range(1, len_j + 1):
            if i == 0:  # 第一行
                item = items[i]
                test_knapsack = Knapsack(capacity=j)
                test_knapsack.add_item(item)
                df.iloc[i][j] = test_knapsack
            else:
                upper_item_value = df.iloc[i - 1][j].all_items_value()
                rightnow_item_value = items[i].value

                if j - items[i].weight == 0:
                    check_value = rightnow_item_value
                elif j - items[i].weight >= 1:
                    check_value = rightnow_item_value + df.iloc[i - 1][j - items[i].weight].all_items_value()
                else:
                    check_value = 0

                test_knapsack = Knapsack(capacity=j)
                if upper_item_value >= check_value:  # 和上面的背包状态一样
                    for item in df.iloc[i - 1][j].items:
                        test_knapsack.add_item(item)
                    df.iloc[i][j] = test_knapsack
                else:
                    if j - items[i].weight == 0:
                        test_knapsack.add_item(items[i])
                    else:
                        test_knapsack.add_item(items[i])
                        for item in df.iloc[i - 1][j - items[i].weight].items:
                            test_knapsack.add_item(item)
                    df.iloc[i][j] = test_knapsack
    print(df)
    return df.iloc[len_i - 1][len_j]
```



## 最长公共子序列问题

```python


"""

和最长公共子序列的区别是必须是递增的。

"""

import pandas as pd


def longest_increasing_subsequence(seq_one, seq_two):
    df = pd.DataFrame(index=[item for item in seq_one], columns=[item for item in seq_two])

    for i, c1 in enumerate(seq_one):
        for j, c2 in enumerate(seq_two):
            if c1 == c2:
                if (i - 1 < 0) or (j - 1 < 0):
                    df.iloc[i][j] = 1
                else:
                    df.iloc[i][j] = df.iloc[i - 1][j - 1] + 1
            else:
                df.iloc[i][j] = 0
    print(df)

longest_increasing_subsequence('fish', 'hish')
longest_increasing_subsequence('hish', 'vista')

```





```python


"""

动态规划法解最长公共子序列问题，经典案例，还是很实用的。

子序列不一定要求递增的，更多的是比较相似度

"""

import pandas as pd


def longest_common_subsequence(seq_one, seq_two):
    df = pd.DataFrame(index=[item for item in seq_one], columns=[item for item in seq_two])

    df = df.fillna(0)

    for i, c1 in enumerate(seq_one):
        for j, c2 in enumerate(seq_two):
            if c1 == c2:
                if (i - 1 < 0) or (j - 1 < 0):
                    df.iloc[i][j] = 1
                else:
                    df.iloc[i][j] = df.iloc[i - 1][j - 1] + 1
            else:
                if i < 1 and j < 1:
                    df.iloc[i][j] = 0
                elif i < 1:
                    df.iloc[i][j] = max(0, df.iloc[i][j - 1])
                elif j < 1:
                    df.iloc[i][j] = max(df.iloc[i - 1][j], 0)
                else:
                    df.iloc[i][j] = max(df.iloc[i - 1][j], df.iloc[i][j - 1])
    print(df)


longest_common_subsequence('fort', 'fosh')
longest_common_subsequence('fish', 'fosh')
```





