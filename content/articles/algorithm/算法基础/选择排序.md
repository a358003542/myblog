Category: algorithm
Tags: algorithm



## 前言

选择排序基本思路是非常直观的，就是遍历序列，找到最小的那个，将其放在第一位，然后剩下的继续找最小的。作为排序算法的第二梯队，第一梯队是指快速排序和其他变种，冒泡排序显得有点故弄玄虚了。对于不是特别的大型序列来说，实际上选择排序仍然是不错的算法。

## C语言版本

```c
void select_sort(int array[], int num) {
	int temp;
	for (int i = 0; i < num; i++) {
		for (int j = i + 1; j < num; j++) {
			if (array[i] > array[j]) {
				temp = array[i];
				array[i] = array[j];
				array[j] = temp;
			}
		}
	}
}
```

## python语言版本

```python
def selection_sort(seq):
    res = list(seq.copy())
    for i in range(0, len(res)):
        minimum = i
        for j in range(i + 1, len(res)):
            if res[j] < res[minimum]:
                minimum = j
        res[i], res[minimum] = res[minimum], res[i]

    return res
```

基本过程都大同小异，就是利用两个遍历动作来形成A,B这样的比较对，然后再决定采取什么行为。python语言版本一些额外的动作是因为希望返回的序列是另外的序列，原序列必变，而C语言版本原数组是就地修改的。

## 算法复杂度

选择排序计算复杂度粗略估计是长度的 $O(n^2)$ ，核心占用时间动作就是那个循环套循环。

这里就顺便说下快速排序，同样的python语言版本，10000个随机数列表排序用时如下：

```
    10000 的随机数列表排序：
    select_sort use time 3.0919713973999023
    quick sort use time 0.024930477142333984
```

我们看到快速排序相比选择排序确实快了太多了。